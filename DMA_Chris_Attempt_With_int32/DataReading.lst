CCS PCD C Compiler, Version 5.071d, 1               07-Jul-17 15:43
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   E:\BoardTest_Chris - Attempt to work with int32\DataReading.lst

               ROM used:   1590 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   151 (0%) at main() level
                           155 (0%) worst case
               Stack used: 66 locations (14 in main + 52 for interrupts)
               Stack size: 128

*
00000:  GOTO    53C
*
00014:  DATA    98,03,00
*
0001C:  DATA    A6,04,00
*
0003C:  DATA    CC,02,00
.................... #include <24EP256GP202.h> 
.................... //////////// Standard Header file for the PIC24EP256GP202 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24EP256GP202 
*
00200:  CLR     54
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    44,61,00
0020E:  DATA    74,61,00
00210:  DATA    20,52,00
00212:  DATA    65,61,00
00214:  DATA    64,69,00
00216:  DATA    6E,67,00
00218:  DATA    20,0A,00
0021A:  DATA    0D,00,00
0021C:  CLR     54
0021E:  MOV     #228,W3
00220:  ADD     W3,W0,W0
00222:  TBLRDL.B[W0],W0L
00224:  CLR.B   1
00226:  RETURN  
00228:  DATA    57,61,00
0022A:  DATA    69,74,00
0022C:  DATA    69,6E,00
0022E:  DATA    67,20,00
00230:  DATA    66,6F,00
00232:  DATA    72,20,00
00234:  DATA    44,61,00
00236:  DATA    74,61,00
00238:  DATA    20,43,00
0023A:  DATA    6C,6F,00
0023C:  DATA    63,6B,00
0023E:  DATA    20,0A,00
00240:  DATA    0D,00,00
00242:  CLR     54
00244:  MOV     #24E,W3
00246:  ADD     W3,W0,W0
00248:  TBLRDL.B[W0],W0L
0024A:  CLR.B   1
0024C:  RETURN  
0024E:  DATA    44,4D,00
00250:  DATA    41,20,00
00252:  DATA    54,72,00
00254:  DATA    61,6E,00
00256:  DATA    73,66,00
00258:  DATA    65,72,00
0025A:  DATA    20,43,00
0025C:  DATA    6F,6D,00
0025E:  DATA    70,6C,00
00260:  DATA    65,74,00
00262:  DATA    65,20,00
00264:  DATA    0A,0D,00
00266:  DATA    00,00,00
00268:  CLR     54
0026A:  MOV     #274,W3
0026C:  ADD     W3,W0,W0
0026E:  TBLRDL.B[W0],W0L
00270:  CLR.B   1
00272:  RETURN  
00274:  DATA    43,68,00
00276:  DATA    61,6E,00
00278:  DATA    6E,65,00
0027A:  DATA    6C,5B,00
0027C:  DATA    30,5D,00
0027E:  DATA    20,69,00
00280:  DATA    73,3A,00
00282:  DATA    20,25,00
00284:  DATA    75,20,00
00286:  DATA    0A,0D,00
00288:  DATA    00,00,00
0028A:  CLR     54
0028C:  MOV     #296,W3
0028E:  ADD     W3,W0,W0
00290:  TBLRDL.B[W0],W0L
00292:  CLR.B   1
00294:  RETURN  
00296:  DATA    54,65,00
00298:  DATA    73,74,00
0029A:  DATA    31,20,00
0029C:  DATA    0A,0D,00
0029E:  DATA    00,00,00
002A0:  CLR     54
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    4E,6F,00
002AE:  DATA    20,0A,00
002B0:  DATA    0D,00,00
002B2:  CLR     54
002B4:  MOV     #2BE,W3
002B6:  ADD     W3,W0,W0
002B8:  TBLRDL.B[W0],W0L
002BA:  CLR.B   1
002BC:  RETURN  
002BE:  DATA    44,4D,00
002C0:  DATA    41,20,00
002C2:  DATA    56,61,00
002C4:  DATA    6C,69,00
002C6:  DATA    64,3A,00
002C8:  DATA    20,25,00
002CA:  DATA    75,00,00
*
003D4:  MOV     W5,[W15++]
003D6:  MOV     #C,W5
003D8:  REPEAT  #3
003DA:  MOV     [W5++],[W15++]
003DC:  MOV     W0,W7
003DE:  MOV     W4,W9
003E0:  BCLR    W4.F
003E2:  CP0     W4
003E4:  BRA     NZ,3F2
003E6:  BTSC    W9.F
003E8:  BRA     3EE
003EA:  MOV     #0,W5
003EC:  BRA     410
003EE:  MOV     #0,W5
003F0:  BRA     410
003F2:  SUB.B   W4L,#6,W5L
003F4:  BRA     NC,40E
003F6:  MOV     #30,W0
003F8:  BTSS    W9.F
003FA:  MOV     #20,W0
003FC:  MOV     W0,[W15++]
003FE:  BTSC.B  223.1
00400:  BRA     3FE
00402:  MOV     W0,224
00404:  MOV     [--W15],W0
00406:  DEC     W5,W5
00408:  BRA     NN,3FC
0040A:  MOV     #5,W5
0040C:  BRA     410
0040E:  MOV     W4,W5
00410:  MOV     #6,W4
00412:  BSET    W5.E
00414:  BTSC    W9.F
00416:  BSET    W5.F
00418:  MOV     #2710,W8
0041A:  REPEAT  #11
0041C:  DIV.U   W7,W8
0041E:  CALL    452
00422:  MOV     W1,W7
00424:  MOV     #3E8,W8
00426:  REPEAT  #11
00428:  DIV.U   W7,W8
0042A:  CALL    452
0042E:  MOV     W1,W7
00430:  MOV     #64,W8
00432:  REPEAT  #11
00434:  DIV.U   W7,W8
00436:  CALL    452
0043A:  MOV     W1,W7
0043C:  MOV     #A,W8
0043E:  REPEAT  #11
00440:  DIV.U   W7,W8
00442:  CALL    452
00446:  MOV     #30,W0
00448:  ADD.B   W1L,W0L,W0L
0044A:  BTSC.B  223.1
0044C:  BRA     44A
0044E:  MOV     W0,224
00450:  BRA     480
00452:  MOV     #30,W6
00454:  CP0     W0
00456:  BRA     NZ,474
00458:  BTSS    W5.E
0045A:  BRA     476
0045C:  DEC     W4,W4
0045E:  CP.B    W4L,W5L
00460:  BRA     Z,466
00462:  BTSC.B  42.0
00464:  RETURN  
00466:  CP0     W0
00468:  BRA     NZ,474
0046A:  BTSS    W5.E
0046C:  BRA     476
0046E:  BTSS    W5.F
00470:  MOV     #20,W6
00472:  BRA     476
00474:  BCLR    W5.E
00476:  ADD.B   W6L,W0L,W0L
00478:  BTSC.B  223.1
0047A:  BRA     478
0047C:  MOV     W0,224
0047E:  RETURN  
00480:  MOV     #12,W5
00482:  REPEAT  #3
00484:  MOV     [--W15],[W5--]
00486:  MOV     [--W15],W5
00488:  RETURN  
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#device icd=true 
.................... //#FUSES FRC_PLL 
.................... #FUSES HS,PR_PLL 
....................  
.................... #use delay(xtal = 10MHZ, clock = 140MHz) 
*
0051C:  CP0     W0
0051E:  BTSC.B  42.1
00520:  BRA     53A
00522:  REPEAT  #116B
00524:  NOP     
00526:  REPEAT  #3FFE
00528:  NOP     
0052A:  REPEAT  #3FFE
0052C:  NOP     
0052E:  REPEAT  #3FFE
00530:  NOP     
00532:  REPEAT  #3FFE
00534:  NOP     
00536:  DEC     W0,W0
00538:  BRA     NZ,522
0053A:  RETURN  
....................  
.................... #pin_select U1TX = PIN_B11 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232(UART1, baud = 115200, stream = UART_PORT1) 
.................... //#USE RS232(STREAM=UART1, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500, XMIT = PIN_B14, RCV = PIN_B15 )) 
.................... #BANK_DMA  int8 channel[8]; 
.................... int count, bitCount = 0; 
.................... #pin_select INT1 = PIN_B6 
.................... //#define SPI_CS PIN_B6 
.................... //unsigned int32 channel[8];   
.................... //int channel[8]; 
....................  
.................... int1 flag = 0; 
.................... int j = 0; 
.................... //#DEFINE ENABLE_INTERRUPTS(PIN_B11); 
....................  
.................... void clear_channel() 
*
0048A:  MOV     W5,[W15++]
0048C:  CLR     101A
.................... { 
....................    int i = 0; 
....................    while(i < 8){ 
0048E:  MOV     101A,W4
00490:  CP      W4,#8
00492:  BRA     GE,4A2
....................       channel[i] = 0; 
00494:  MOV     #1002,W4
00496:  MOV     101A,W3
00498:  ADD     W3,W4,W5
0049A:  CLR.B   [W5]
....................       i++; 
0049C:  INC     101A
0049E:  GOTO    48E
....................    } 
004A2:  MOV     [--W15],W5
004A4:  RETURN  
.................... } 
....................  
.................... #INT_EXT1 
.................... void DCLK_interrupt_handler() 
*
002CC:  PUSH    42
002CE:  PUSH    36
002D0:  PUSH    54
002D2:  MOV     W0,[W15++]
002D4:  MOV     #2,W0
002D6:  REPEAT  #C
002D8:  MOV     [W0++],[W15++]
.................... {   
....................          while(j <= 8){ 
002DA:  MOV     1010,W4
002DC:  CP      W4,#8
002DE:  BRA     GT,2F4
....................          //shift bits left for next inputDMA0   DMA channel 0 transfer complete 
....................             channel[j] <<= 1; 
002E0:  MOV     #1002,W4
002E2:  MOV     1010,W3
002E4:  ADD     W3,W4,W5
002E6:  MOV.B   [W5],W0L
002E8:  CLR.B   1
002EA:  SL      W0,#1,W0
002EC:  MOV.B   W0L,[W5]
....................             j++; 
002EE:  INC     1010
002F0:  GOTO    2DA
....................          } 
....................          j = 0; 
002F4:  CLR     1010
....................          //Accept inputs 1 bit at a time 
....................          channel[0] += input(PIN_B0); 
002F6:  BSET.B  E10.0
002F8:  CLR     W0
002FA:  BTSC.B  E12.0
002FC:  INC     W0,W0
002FE:  ADD.B   1002
....................          channel[1] += input(PIN_B1); 
00300:  BSET.B  E10.1
00302:  CLR     W0
00304:  BTSC.B  E12.1
00306:  INC     W0,W0
00308:  ADD.B   1003
....................          channel[2] += input(PIN_B2); 
0030A:  BSET.B  E10.2
0030C:  CLR     W0
0030E:  BTSC.B  E12.2
00310:  INC     W0,W0
00312:  ADD.B   1004
....................          channel[3] += input(PIN_B3); 
00314:  BSET.B  E10.3
00316:  CLR     W0
00318:  BTSC.B  E12.3
0031A:  INC     W0,W0
0031C:  ADD.B   1005
....................          channel[4] += input(PIN_B4); 
0031E:  BSET.B  E10.4
00320:  CLR     W0
00322:  BTSC.B  E12.4
00324:  INC     W0,W0
00326:  ADD.B   1006
....................          channel[5] += input(PIN_B5); 
00328:  BSET.B  E10.5
0032A:  CLR     W0
0032C:  BTSC.B  E12.5
0032E:  INC     W0,W0
00330:  ADD.B   1007
....................          channel[6] += input(PIN_B6); 
00332:  BSET.B  E10.6
00334:  CLR     W0
00336:  BTSC.B  E12.6
00338:  INC     W0,W0
0033A:  ADD.B   1008
....................          channel[7] += input(PIN_B7); 
0033C:  BSET.B  E10.7
0033E:  CLR     W0
00340:  BTSC.B  E12.7
00342:  INC     W0,W0
00344:  ADD.B   1009
....................          //Possible take whole port at one time??? 
....................          //inputPortB = input_b(); 
....................          bitCount++; 
00346:  INC     100C
....................          printf("Data Reading \n\r"); 
00348:  MOV     #0,W1
0034A:  MOV     W1,W0
0034C:  CLR.B   1
0034E:  CALL    200
00352:  INC     W1,W1
00354:  BTSC.B  223.1
00356:  BRA     354
00358:  MOV     W0,224
0035A:  MOV     #E,W0
0035C:  CPSGT   W1,W0
0035E:  BRA     34A
....................          if (bitCount == 8){ 
00360:  MOV     100C,W4
00362:  CP      W4,#8
00364:  BRA     NZ,386
....................  
....................             dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0]); 
00366:  BCLR.B  B01.7
00368:  MOV.B   #1,W0L
0036A:  MOV.B   W0L,B00
0036C:  MOV     #1002,W4
0036E:  MOV     W4,B04
00370:  CLR     B06
00372:  BTSS.B  B01.6
00374:  BRA     37C
00376:  MOV     #7,W4
00378:  MOV     W4,B0E
0037A:  BRA     380
0037C:  MOV     #3,W4
0037E:  MOV     W4,B0E
00380:  BSET.B  B01.7
00382:  BSET.B  B03.7
....................             bitCount = 0; 
00384:  CLR     100C
....................          } 
.................... //!   else{ 
.................... //!      printf("24 bits\n\r"); 
.................... //!      bitCount = 0; 
.................... //!      dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0]); 
.................... //!   } 
.................... } 
....................  
....................  
00386:  BCLR.B  802.4
00388:  MOV     #1A,W0
0038A:  REPEAT  #C
0038C:  MOV     [--W15],[W0--]
0038E:  MOV     [--W15],W0
00390:  POP     54
00392:  POP     36
00394:  POP     42
00396:  RETFIE  
.................... #INT_EXT0 
.................... void DRDY_interrupt_handler() 
00398:  PUSH    42
0039A:  PUSH    36
0039C:  PUSH    54
0039E:  MOV     W0,[W15++]
003A0:  MOV     #2,W0
003A2:  REPEAT  #C
003A4:  MOV     [W0++],[W15++]
.................... { 
....................    CLEAR_INTERRUPT(INT_EXT1); 
003A6:  BCLR.B  802.4
....................    ENABLE_INTERRUPTS(INT_EXT1); 
003A8:  BSET.B  822.4
....................    printf("Waiting for Data Clock \n\r"); 
003AA:  MOV     #0,W1
003AC:  MOV     W1,W0
003AE:  CLR.B   1
003B0:  CALL    21C
003B4:  INC     W1,W1
003B6:  BTSC.B  223.1
003B8:  BRA     3B6
003BA:  MOV     W0,224
003BC:  MOV     #18,W0
003BE:  CPSGT   W1,W0
003C0:  BRA     3AC
....................  
.................... } 
003C2:  BCLR.B  800.0
003C4:  MOV     #1A,W0
003C6:  REPEAT  #C
003C8:  MOV     [--W15],[W0--]
003CA:  MOV     [--W15],W0
003CC:  POP     54
003CE:  POP     36
003D0:  POP     42
003D2:  RETFIE  
.................... #INT_DMA0 
.................... void DMA_interrupt_handler() 
*
004A6:  PUSH    42
004A8:  PUSH    36
004AA:  PUSH    54
004AC:  MOV     W0,[W15++]
004AE:  MOV     #2,W0
004B0:  REPEAT  #C
004B2:  MOV     [W0++],[W15++]
.................... { 
....................    printf("DMA Transfer Complete \n\r"); 
004B4:  MOV     #0,W1
004B6:  MOV     W1,W0
004B8:  CLR.B   1
004BA:  CALL    242
004BE:  INC     W1,W1
004C0:  BTSC.B  223.1
004C2:  BRA     4C0
004C4:  MOV     W0,224
004C6:  MOV     #17,W0
004C8:  CPSGT   W1,W0
004CA:  BRA     4B6
....................    printf("Channel[0] is: %u \n\r", channel[0]);  
004CC:  MOV     #0,W1
004CE:  MOV     W1,W0
004D0:  CLR.B   1
004D2:  CALL    268
004D6:  INC     W1,W1
004D8:  BTSC.B  223.1
004DA:  BRA     4D8
004DC:  MOV     W0,224
004DE:  MOV     #E,W0
004E0:  CPSGT   W1,W0
004E2:  BRA     4CE
004E4:  MOV.B   1002,W0L
004E6:  CLR.B   1
004E8:  MOV     #0,W4
004EA:  CALL    3D4
004EE:  BTSC.B  223.1
004F0:  BRA     4EE
004F2:  MOV     #20,W4
004F4:  MOV     W4,224
004F6:  BTSC.B  223.1
004F8:  BRA     4F6
004FA:  MOV     #A,W4
004FC:  MOV     W4,224
004FE:  BTSC.B  223.1
00500:  BRA     4FE
00502:  MOV     #D,W4
00504:  MOV     W4,224
....................    clear_channel(); 
00506:  CALL    48A
0050A:  BCLR.B  800.4
0050C:  MOV     #1A,W0
0050E:  REPEAT  #C
00510:  MOV     [--W15],[W0--]
00512:  MOV     [--W15],W0
00514:  POP     54
00516:  POP     36
00518:  POP     42
0051A:  RETFIE  
.................... } 
....................  
....................  
.................... void main(){ 
*
0053C:  MOV     #7F80,W15
0053E:  MOV     #7FFF,W0
00540:  MOV     W0,20
00542:  NOP     
00544:  BSET.B  8C1.7
00546:  DISI    #6
00548:  MOV     #742,W1
0054A:  MOV     #46,W2
0054C:  MOV     #57,W3
0054E:  MOV.B   W2L,[W1]
00550:  MOV.B   W3L,[W1]
00552:  BCLR.B  742.6
00554:  MOV     #2600,W0
00556:  MOV     W0,6A0
00558:  MOV     #2C,W0
0055A:  MOV     W0,6C4
0055C:  MOV     #100,W0
0055E:  MOV     W0,688
00560:  DISI    #6
00562:  MOV     #742,W1
00564:  MOV     #46,W2
00566:  MOV     #57,W3
00568:  MOV.B   W2L,[W1]
0056A:  MOV.B   W3L,[W1]
0056C:  BSET.B  742.6
0056E:  CLR     744
00570:  MOV     #36,W4
00572:  MOV     W4,746
00574:  DISI    #E
00576:  MOV     #103,W0
00578:  MOV     #743,W1
0057A:  MOV     #78,W2
0057C:  MOV     #9A,W3
0057E:  MOV.B   W2L,[W1]
00580:  MOV.B   W3L,[W1]
00582:  MOV.B   W0L,743
00584:  LSR     W0,#8,W0
00586:  MOV     #742,W1
00588:  MOV     #46,W2
0058A:  MOV     #57,W3
0058C:  MOV.B   W2L,[W1]
0058E:  MOV.B   W3L,[W1]
00590:  MOV.B   W0L,[W1]
00592:  MOV     #8000,W4
00594:  MOV     W4,220
00596:  MOV     #400,W4
00598:  MOV     W4,222
0059A:  BCLR.B  220.3
0059C:  MOV     #25,W4
0059E:  MOV     W4,228
005A0:  CLR     100C
005A2:  BCLR.B  100E.0
005A4:  CLR     1010
005A6:  CLR     E0E
005A8:  CLR     E1E
005AA:  CLR     1000
.................... //#BIT INT0EP = 0x08C2.0; 
....................    delay_ms(50); 
005AC:  MOV     #32,W0
005AE:  CALL    51C
....................    EXT_INT_EDGE(L_TO_H); 
005B2:  BCLR.B  8C2.0
....................    int Value; 
....................     
.................... //   INT0EP = 1; // negative edge 
....................     
....................    CLEAR_INTERRUPT(INT_EXT0); 
005B4:  BCLR.B  800.0
....................    ENABLE_INTERRUPTS(INT_EXT0); 
005B6:  BSET.B  820.0
....................    CLEAR_INTERRUPT(INT_DMA0); 
005B8:  BCLR.B  800.4
....................    ENABLE_INTERRUPTS(INT_DMA0); 
005BA:  BSET.B  820.4
....................  
....................   // ENABLE_INTERRUPTS(INTR_NORMAL); 
....................    ENABLE_INTERRUPTS(INTR_GLOBAL); 
005BC:  BSET.B  8C3.7
....................     
....................    setup_dma(0,DMA_OUT_UART1,DMA_BYTE);    
005BE:  MOV.B   #60,W0L
005C0:  MOV.B   W0L,B01
005C2:  MOV.B   #C,W0L
005C4:  MOV.B   W0L,B02
005C6:  MOV     #224,W4
005C8:  MOV     W4,B0C
....................    //dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................    int i = 0; 
005CA:  CLR     1014
005CC:  PUSH    8C2
005CE:  BCLR.B  8C3.7
....................    //initialize the array 
....................    clear_channel(); 
005D0:  CALL    48A
005D4:  POP     8C2
....................     
....................    printf("Test1 \n\r"); 
005D6:  MOV     #0,W1
005D8:  MOV     W1,W0
005DA:  CLR.B   1
005DC:  CALL    28A
005E0:  INC     W1,W1
005E2:  BTSC.B  223.1
005E4:  BRA     5E2
005E6:  MOV     W0,224
005E8:  MOV     #7,W0
005EA:  CPSGT   W1,W0
005EC:  BRA     5D8
.................... //!  while(count != 5){ 
.................... //!   output_high(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   output_low(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   printf("Hello, World! \n\r"); 
.................... //!   count++; 
.................... //!   } 
....................    while(1) 
....................    { 
....................       delay_ms(2000); 
005EE:  MOV     #7D0,W0
005F0:  CALL    51C
....................       printf("No \n\r"); 
005F4:  MOV     #0,W1
005F6:  MOV     W1,W0
005F8:  CLR.B   1
005FA:  CALL    2A0
005FE:  INC     W1,W1
00600:  BTSC.B  223.1
00602:  BRA     600
00604:  MOV     W0,224
00606:  MOV     #4,W0
00608:  CPSGT   W1,W0
0060A:  BRA     5F6
0060C:  GOTO    5EE
....................       //Value = dma_status(0); 
....................       //printf("DMA status: %u \n\r", Value); 
....................      // dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................       
....................    } 
....................    //printf("ch0 is:%u \n\r",ch0); 
....................    int support = getenv("DMA"); 
00610:  MOV     #1,W4
00612:  MOV     W4,1016
....................    printf("DMA Valid: %u", support); 
00614:  MOV     #0,W1
00616:  MOV     W1,W0
00618:  CLR.B   1
0061A:  CALL    2B2
0061E:  INC     W1,W1
00620:  BTSC.B  223.1
00622:  BRA     620
00624:  MOV     W0,224
00626:  MOV     #A,W0
00628:  CPSGT   W1,W0
0062A:  BRA     616
0062C:  MOV     1016,W0
0062E:  MOV     #0,W4
00630:  CALL    3D4
....................  
.................... } 
*
00634:  PWRSAV  #0

Configuration Fuses:
   Word  3L: FFCF   ICSP1 NOJTAG NODEBUG
          H: 0000  
   Word  4L: FFFF   NOALTI2C1 NOALTI2C2 WDTWIN_25%
          H: 0000  
   Word  5L: FF7F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: 0000  
   Word  6L: FF7A   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  7L: FFF8   FRC IESO
          H: 0000  
   Word  8L: FFFF   NOWRT NOPROTECT
          H: 0000  
   Word  9L: FFFF  
          H: 0000  
   Word 10L: FFFF  
          H: 0000  
