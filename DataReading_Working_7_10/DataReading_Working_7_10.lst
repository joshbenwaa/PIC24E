CCS PCD C Compiler, Version 5.071d, 1               10-Jul-17 15:02
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\joshb\OneDrive - St. Cloud State University\PIC24E\DataReading_Working_7_10\DataReading_Working_7_10.lst

               ROM used:   2072 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   170 (1%) at main() level
                           184 (1%) worst case
               Stack used: 74 locations (18 in main + 56 for interrupts)
               Stack size: 128

*
00000:  GOTO    712
*
00014:  DATA    5A,05,00
*
0001C:  DATA    4C,06,00
*
0003C:  DATA    48,04,00
.................... #include <24EP256GP202.h> 
.................... //////////// Standard Header file for the PIC24EP256GP202 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24EP256GP202 
*
00200:  CLR     54
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    25,64,00
0020E:  DATA    20,20,00
00210:  DATA    20,20,00
00212:  DATA    20,00,00
00214:  CLR     54
00216:  MOV     #220,W3
00218:  ADD     W3,W0,W0
0021A:  TBLRDL.B[W0],W0L
0021C:  CLR.B   1
0021E:  RETURN  
00220:  DATA    44,61,00
00222:  DATA    74,61,00
00224:  DATA    20,52,00
00226:  DATA    65,61,00
00228:  DATA    64,69,00
0022A:  DATA    6E,67,00
0022C:  DATA    20,0A,00
0022E:  DATA    0D,00,00
00230:  CLR     54
00232:  MOV     #23C,W3
00234:  ADD     W3,W0,W0
00236:  TBLRDL.B[W0],W0L
00238:  CLR.B   1
0023A:  RETURN  
0023C:  DATA    57,61,00
0023E:  DATA    69,74,00
00240:  DATA    69,6E,00
00242:  DATA    67,20,00
00244:  DATA    66,6F,00
00246:  DATA    72,20,00
00248:  DATA    44,61,00
0024A:  DATA    74,61,00
0024C:  DATA    20,43,00
0024E:  DATA    6C,6F,00
00250:  DATA    63,6B,00
00252:  DATA    20,0A,00
00254:  DATA    0D,00,00
00256:  CLR     54
00258:  MOV     #262,W3
0025A:  ADD     W3,W0,W0
0025C:  TBLRDL.B[W0],W0L
0025E:  CLR.B   1
00260:  RETURN  
00262:  DATA    44,4D,00
00264:  DATA    41,20,00
00266:  DATA    54,72,00
00268:  DATA    61,6E,00
0026A:  DATA    73,66,00
0026C:  DATA    65,72,00
0026E:  DATA    20,43,00
00270:  DATA    6F,6D,00
00272:  DATA    70,6C,00
00274:  DATA    65,74,00
00276:  DATA    65,20,00
00278:  DATA    0A,0D,00
0027A:  DATA    00,00,00
0027C:  CLR     54
0027E:  MOV     #288,W3
00280:  ADD     W3,W0,W0
00282:  TBLRDL.B[W0],W0L
00284:  CLR.B   1
00286:  RETURN  
00288:  DATA    43,68,00
0028A:  DATA    61,6E,00
0028C:  DATA    6E,65,00
0028E:  DATA    6C,5B,00
00290:  DATA    30,5D,00
00292:  DATA    5B,30,00
00294:  DATA    5D,20,00
00296:  DATA    69,73,00
00298:  DATA    3A,20,00
0029A:  DATA    25,75,00
0029C:  DATA    20,0A,00
0029E:  DATA    0D,00,00
002A0:  CLR     54
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    54,65,00
002AE:  DATA    73,74,00
002B0:  DATA    31,20,00
002B2:  DATA    0A,0D,00
002B4:  DATA    00,00,00
002B6:  CLR     54
002B8:  MOV     #2C2,W3
002BA:  ADD     W3,W0,W0
002BC:  TBLRDL.B[W0],W0L
002BE:  CLR.B   1
002C0:  RETURN  
002C2:  DATA    4E,6F,00
002C4:  DATA    20,0A,00
002C6:  DATA    0D,00,00
002C8:  CLR     54
002CA:  MOV     #2D4,W3
002CC:  ADD     W3,W0,W0
002CE:  TBLRDL.B[W0],W0L
002D0:  CLR.B   1
002D2:  RETURN  
002D4:  DATA    44,4D,00
002D6:  DATA    41,20,00
002D8:  DATA    56,61,00
002DA:  DATA    6C,69,00
002DC:  DATA    64,3A,00
002DE:  DATA    20,25,00
002E0:  DATA    75,00,00
002E2:  MOV     W5,[W15++]
002E4:  MOV     #C,W5
002E6:  REPEAT  #3
002E8:  MOV     [W5++],[W15++]
002EA:  BTSS    W0.F
002EC:  BRA     306
002EE:  NEG     W0,W0
002F0:  BSET    W4.8
002F2:  BTSS    W4.F
002F4:  BRA     306
002F6:  MOV     W0,[W15++]
002F8:  MOV     #2D,W0
002FA:  BTSC.B  223.1
002FC:  BRA     2FA
002FE:  MOV     W0,224
00300:  MOV     [--W15],W0
00302:  BCLR    W4.8
00304:  DEC.B   0008
00306:  CLR     W5
00308:  MOV     W0,W7
0030A:  MOV     W4,W9
0030C:  BCLR    W4.F
0030E:  CP0.B   W4L
00310:  BRA     NZ,31E
00312:  BTSC    W9.F
00314:  BRA     31A
00316:  MOV     #0,W5
00318:  BRA     342
0031A:  MOV     #0,W5
0031C:  BRA     342
0031E:  BTSS    W9.8
00320:  SUB.B   W4L,#6,W5L
00322:  BTSC    W9.8
00324:  SUB.B   W4L,#7,W5L
00326:  BRA     NC,340
00328:  MOV     #30,W0
0032A:  BTSS    W9.F
0032C:  MOV     #20,W0
0032E:  MOV     W0,[W15++]
00330:  BTSC.B  223.1
00332:  BRA     330
00334:  MOV     W0,224
00336:  MOV     [--W15],W0
00338:  DEC     W5,W5
0033A:  BRA     NN,32E
0033C:  MOV     #5,W5
0033E:  BRA     342
00340:  MOV     W4,W5
00342:  MOV     #6,W4
00344:  BTSC    W5.8
00346:  INC     W4,W4
00348:  BSET    W5.E
0034A:  BTSC    W9.F
0034C:  BSET    W5.F
0034E:  MOV     #2710,W8
00350:  REPEAT  #11
00352:  DIV.U   W7,W8
00354:  CALL    398
00358:  MOV     W1,W7
0035A:  MOV     #3E8,W8
0035C:  REPEAT  #11
0035E:  DIV.U   W7,W8
00360:  CALL    398
00364:  MOV     W1,W7
00366:  MOV     #64,W8
00368:  REPEAT  #11
0036A:  DIV.U   W7,W8
0036C:  CALL    398
00370:  MOV     W1,W7
00372:  MOV     #A,W8
00374:  REPEAT  #11
00376:  DIV.U   W7,W8
00378:  CALL    398
0037C:  BTSS    W9.8
0037E:  BRA     38A
00380:  MOV     #2D,W0
00382:  BTSC.B  223.1
00384:  BRA     382
00386:  MOV     W0,224
00388:  BCLR    W9.8
0038A:  MOV     #30,W0
0038C:  ADD.B   W1L,W0L,W0L
0038E:  MOV     W0,2A
00390:  BTSC.B  223.1
00392:  BRA     390
00394:  MOV     W0,224
00396:  BRA     3D8
00398:  MOV     #30,W6
0039A:  CP0     W0
0039C:  BRA     NZ,3BA
0039E:  BTSS    W5.E
003A0:  BRA     3CE
003A2:  DEC     W4,W4
003A4:  CP.B    W4L,W5L
003A6:  BRA     Z,3AC
003A8:  BTSC.B  42.0
003AA:  RETURN  
003AC:  CP0     W0
003AE:  BRA     NZ,3BA
003B0:  BTSS    W5.E
003B2:  BRA     3CE
003B4:  BTSS    W5.F
003B6:  MOV     #20,W6
003B8:  BRA     3CE
003BA:  BCLR    W5.E
003BC:  BTSS    W9.8
003BE:  BRA     3CE
003C0:  MOV     W0,W10
003C2:  MOV     #2D,W0
003C4:  BTSC.B  223.1
003C6:  BRA     3C4
003C8:  MOV     W0,224
003CA:  BCLR    W9.8
003CC:  MOV     W10,W0
003CE:  ADD.B   W6L,W0L,W0L
003D0:  BTSC.B  223.1
003D2:  BRA     3D0
003D4:  MOV     W0,224
003D6:  RETURN  
003D8:  MOV     #12,W5
003DA:  REPEAT  #3
003DC:  MOV     [--W15],[W5--]
003DE:  MOV     [--W15],W5
003E0:  RETURN  
*
00596:  MOV     W5,[W15++]
00598:  MOV     #C,W5
0059A:  REPEAT  #3
0059C:  MOV     [W5++],[W15++]
0059E:  MOV     W0,W7
005A0:  MOV     W4,W9
005A2:  BCLR    W4.F
005A4:  CP0     W4
005A6:  BRA     NZ,5B4
005A8:  BTSC    W9.F
005AA:  BRA     5B0
005AC:  MOV     #0,W5
005AE:  BRA     5D2
005B0:  MOV     #0,W5
005B2:  BRA     5D2
005B4:  SUB.B   W4L,#6,W5L
005B6:  BRA     NC,5D0
005B8:  MOV     #30,W0
005BA:  BTSS    W9.F
005BC:  MOV     #20,W0
005BE:  MOV     W0,[W15++]
005C0:  BTSC.B  223.1
005C2:  BRA     5C0
005C4:  MOV     W0,224
005C6:  MOV     [--W15],W0
005C8:  DEC     W5,W5
005CA:  BRA     NN,5BE
005CC:  MOV     #5,W5
005CE:  BRA     5D2
005D0:  MOV     W4,W5
005D2:  MOV     #6,W4
005D4:  BSET    W5.E
005D6:  BTSC    W9.F
005D8:  BSET    W5.F
005DA:  MOV     #2710,W8
005DC:  REPEAT  #11
005DE:  DIV.U   W7,W8
005E0:  CALL    614
005E4:  MOV     W1,W7
005E6:  MOV     #3E8,W8
005E8:  REPEAT  #11
005EA:  DIV.U   W7,W8
005EC:  CALL    614
005F0:  MOV     W1,W7
005F2:  MOV     #64,W8
005F4:  REPEAT  #11
005F6:  DIV.U   W7,W8
005F8:  CALL    614
005FC:  MOV     W1,W7
005FE:  MOV     #A,W8
00600:  REPEAT  #11
00602:  DIV.U   W7,W8
00604:  CALL    614
00608:  MOV     #30,W0
0060A:  ADD.B   W1L,W0L,W0L
0060C:  BTSC.B  223.1
0060E:  BRA     60C
00610:  MOV     W0,224
00612:  BRA     642
00614:  MOV     #30,W6
00616:  CP0     W0
00618:  BRA     NZ,636
0061A:  BTSS    W5.E
0061C:  BRA     638
0061E:  DEC     W4,W4
00620:  CP.B    W4L,W5L
00622:  BRA     Z,628
00624:  BTSC.B  42.0
00626:  RETURN  
00628:  CP0     W0
0062A:  BRA     NZ,636
0062C:  BTSS    W5.E
0062E:  BRA     638
00630:  BTSS    W5.F
00632:  MOV     #20,W6
00634:  BRA     638
00636:  BCLR    W5.E
00638:  ADD.B   W6L,W0L,W0L
0063A:  BTSC.B  223.1
0063C:  BRA     63A
0063E:  MOV     W0,224
00640:  RETURN  
00642:  MOV     #12,W5
00644:  REPEAT  #3
00646:  MOV     [--W15],[W5--]
00648:  MOV     [--W15],W5
0064A:  RETURN  
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#device icd=true 
.................... //#FUSES FRC_PLL 
.................... #FUSES HS,PR_PLL 
....................  
.................... #use delay(xtal = 10MHZ, clock = 140MHz) 
*
006BE:  CP0     W0
006C0:  BTSC.B  42.1
006C2:  BRA     6DC
006C4:  REPEAT  #116B
006C6:  NOP     
006C8:  REPEAT  #3FFE
006CA:  NOP     
006CC:  REPEAT  #3FFE
006CE:  NOP     
006D0:  REPEAT  #3FFE
006D2:  NOP     
006D4:  REPEAT  #3FFE
006D6:  NOP     
006D8:  DEC     W0,W0
006DA:  BRA     NZ,6C4
006DC:  RETURN  
....................  
.................... #pin_select U1TX = PIN_B11 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232(UART1, baud = 115200, stream = UART_PORT1) 
.................... //#USE RS232(STREAM=UART1, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500, XMIT = PIN_B14, RCV = PIN_B15 )) 
.................... #BANK_DMA  int8 channel[8][3]; 
.................... int count, bitCount = 0; 
.................... #pin_select INT1 = PIN_B6 
.................... //#define SPI_CS PIN_B6 
.................... //unsigned int32 channel[8];   
.................... //int channel[8]; 
.................... int rows = 0, cols = 0 ; 
.................... int1 flag = 0; 
.................... //int j = 0; 
.................... //#DEFINE ENABLE_INTERRUPTS(PIN_B11); 
....................  
.................... void clear_channel() 
006DE:  MOV     W5,[W15++]
006E0:  CLR     102A
006E2:  CLR     102C
.................... { 
....................    int i = 0, k = 0; 
....................    while(i < 8){ 
006E4:  MOV     102A,W4
006E6:  CP      W4,#8
006E8:  BRA     GE,70E
....................       while(k < 3){ 
006EA:  MOV     102C,W4
006EC:  CP      W4,#3
006EE:  BRA     GE,706
....................          channel[i][k] = 0; 
006F0:  MOV     102A,W4
006F2:  MUL.UU  W4,#3,W0
006F4:  MOV     W0,W5
006F6:  MOV     W5,W0
006F8:  ADD     102C,W0
006FA:  MOV     #1002,W4
006FC:  ADD     W0,W4,W5
006FE:  CLR.B   [W5]
....................          k++; 
00700:  INC     102C
00702:  GOTO    6EA
....................       } 
....................       k = 0; 
00706:  CLR     102C
....................       i++; 
00708:  INC     102A
0070A:  GOTO    6E4
....................    } 
0070E:  MOV     [--W15],W5
00710:  RETURN  
.................... } 
....................  
.................... void display_matrix(void) 
*
003E2:  MOV     W5,[W15++]
003E4:  CLR     1030
003E6:  CLR     1032
.................... { 
....................    int row = 0, columns = 0; 
....................    for (row=0; row<3; row++) 
003E8:  CLR     1030
003EA:  MOV     1030,W4
003EC:  CP      W4,#3
003EE:  BRA     GE,444
....................    { 
....................     for(columns=0; columns<8; columns++) 
003F0:  CLR     1032
003F2:  MOV     1032,W4
003F4:  CP      W4,#8
003F6:  BRA     GE,42E
....................         { 
....................          printf("%d     ", channel[row][columns]); 
003F8:  MOV     1030,W4
003FA:  MUL.UU  W4,#3,W0
003FC:  MOV     W0,W5
003FE:  MOV     W5,W0
00400:  ADD     1032,W0
00402:  MOV     #1002,W4
00404:  ADD     W0,W4,W0
00406:  MOV.B   [W0],W5L
00408:  SE      W5,W0
0040A:  MOV     #0,W4
0040C:  CALL    2E2
00410:  MOV     #2,W1
00412:  MOV     W1,W0
00414:  CLR.B   1
00416:  CALL    200
0041A:  INC     W1,W1
0041C:  BTSC.B  223.1
0041E:  BRA     41C
00420:  MOV     W0,224
00422:  MOV     #6,W0
00424:  CPSGT   W1,W0
00426:  BRA     412
00428:  INC     1032
0042A:  GOTO    3F2
....................         } 
....................       printf("\n\r"); 
0042E:  BTSC.B  223.1
00430:  BRA     42E
00432:  MOV     #A,W4
00434:  MOV     W4,224
00436:  BTSC.B  223.1
00438:  BRA     436
0043A:  MOV     #D,W4
0043C:  MOV     W4,224
0043E:  INC     1030
00440:  GOTO    3EA
....................    } 
00444:  MOV     [--W15],W5
00446:  RETURN  
.................... } 
....................  
.................... #INT_EXT1 
.................... void DCLK_interrupt_handler() 
00448:  PUSH    42
0044A:  PUSH    36
0044C:  PUSH    54
0044E:  MOV     W0,[W15++]
00450:  MOV     #2,W0
00452:  REPEAT  #C
00454:  MOV     [W0++],[W15++]
.................... {         
....................          while(rows <= 8){ 
00456:  MOV     101E,W4
00458:  CP      W4,#8
0045A:  BRA     GT,478
....................          //shift bits left for next inputDMA0   DMA channel 0 transfer complete 
....................             channel[rows][cols] <<= 1; 
0045C:  MOV     101E,W4
0045E:  MUL.UU  W4,#3,W0
00460:  MOV     W0,W5
00462:  MOV     W5,W0
00464:  ADD     1020,W0
00466:  MOV     #1002,W4
00468:  ADD     W0,W4,W5
0046A:  MOV.B   [W5],W0L
0046C:  CLR.B   1
0046E:  SL      W0,#1,W0
00470:  MOV.B   W0L,[W5]
....................             rows++; 
00472:  INC     101E
00474:  GOTO    456
....................          } 
....................         // cols = 0; 
....................          //Accept inputs 1 bit at a time 
....................          channel[0][cols] += input(PIN_B0); 
00478:  MOV     #1002,W4
0047A:  MOV     1020,W3
0047C:  ADD     W3,W4,W5
0047E:  BSET.B  E10.0
00480:  CLR     W0
00482:  BTSC.B  E12.0
00484:  INC     W0,W0
00486:  ADD.B   W0L,[W5],[W5]
....................          channel[1][cols] += input(PIN_B1); 
00488:  MOV     #1005,W0
0048A:  ADD     1020,W0
0048C:  MOV     W0,W5
0048E:  BSET.B  E10.1
00490:  CLR     W0
00492:  BTSC.B  E12.1
00494:  INC     W0,W0
00496:  ADD.B   W0L,[W5],[W5]
....................          channel[2][cols] += input(PIN_B2); 
00498:  MOV     #1008,W0
0049A:  ADD     1020,W0
0049C:  MOV     W0,W5
0049E:  BSET.B  E10.2
004A0:  CLR     W0
004A2:  BTSC.B  E12.2
004A4:  INC     W0,W0
004A6:  ADD.B   W0L,[W5],[W5]
....................          channel[3][cols] += input(PIN_B3); 
004A8:  MOV     #100B,W0
004AA:  ADD     1020,W0
004AC:  MOV     W0,W5
004AE:  BSET.B  E10.3
004B0:  CLR     W0
004B2:  BTSC.B  E12.3
004B4:  INC     W0,W0
004B6:  ADD.B   W0L,[W5],[W5]
....................          channel[4][cols] += input(PIN_B4); 
004B8:  MOV     #100E,W0
004BA:  ADD     1020,W0
004BC:  MOV     W0,W5
004BE:  BSET.B  E10.4
004C0:  CLR     W0
004C2:  BTSC.B  E12.4
004C4:  INC     W0,W0
004C6:  ADD.B   W0L,[W5],[W5]
....................          channel[5][cols] += input(PIN_B5); 
004C8:  MOV     #1011,W0
004CA:  ADD     1020,W0
004CC:  MOV     W0,W5
004CE:  BSET.B  E10.5
004D0:  CLR     W0
004D2:  BTSC.B  E12.5
004D4:  INC     W0,W0
004D6:  ADD.B   W0L,[W5],[W5]
....................          channel[6][cols] += input(PIN_B8); //B6 Used by interrupt 
004D8:  MOV     #1014,W0
004DA:  ADD     1020,W0
004DC:  MOV     W0,W5
004DE:  BSET.B  E11.0
004E0:  CLR     W0
004E2:  BTSC.B  E13.0
004E4:  INC     W0,W0
004E6:  ADD.B   W0L,[W5],[W5]
....................          channel[7][cols] += input(PIN_B9); //B7 Used by interrupt 
004E8:  MOV     #1017,W0
004EA:  ADD     1020,W0
004EC:  MOV     W0,W5
004EE:  BSET.B  E11.1
004F0:  CLR     W0
004F2:  BTSC.B  E13.1
004F4:  INC     W0,W0
004F6:  ADD.B   W0L,[W5],[W5]
....................          //Possible take whole port at one time??? 
....................          //inputPortB = input_b(); 
....................          bitCount++; 
004F8:  INC     101C
....................          rows = 0; 
004FA:  CLR     101E
....................          printf("Data Reading \n\r"); 
004FC:  MOV     #0,W1
004FE:  MOV     W1,W0
00500:  CLR.B   1
00502:  CALL    214
00506:  INC     W1,W1
00508:  BTSC.B  223.1
0050A:  BRA     508
0050C:  MOV     W0,224
0050E:  MOV     #E,W0
00510:  CPSGT   W1,W0
00512:  BRA     4FE
....................          if (bitCount == 8){ 
00514:  MOV     101C,W4
00516:  CP      W4,#8
00518:  BRA     NZ,548
....................              cols++; 
0051A:  INC     1020
....................             if(cols == 3){ 
0051C:  MOV     1020,W4
0051E:  CP      W4,#3
00520:  BRA     NZ,528
....................                cols = 0; 
00522:  CLR     1020
....................                display_matrix(); 
00524:  CALL    3E2
....................             } 
....................             dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0][0]); 
00528:  BCLR.B  B01.7
0052A:  MOV.B   #1,W0L
0052C:  MOV.B   W0L,B00
0052E:  MOV     #1002,W4
00530:  MOV     W4,B04
00532:  CLR     B06
00534:  BTSS.B  B01.6
00536:  BRA     53E
00538:  MOV     #17,W4
0053A:  MOV     W4,B0E
0053C:  BRA     542
0053E:  MOV     #B,W4
00540:  MOV     W4,B0E
00542:  BSET.B  B01.7
00544:  BSET.B  B03.7
....................             bitCount = 0; 
00546:  CLR     101C
....................          } 
....................           
.................... //!   else{ 
.................... //!      printf("24 bits\n\r"); 
.................... //!      bitCount = 0; 
.................... //!      dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0]); 
.................... //!   } 
.................... } 
....................  
....................  
00548:  BCLR.B  802.4
0054A:  MOV     #1A,W0
0054C:  REPEAT  #C
0054E:  MOV     [--W15],[W0--]
00550:  MOV     [--W15],W0
00552:  POP     54
00554:  POP     36
00556:  POP     42
00558:  RETFIE  
.................... #INT_EXT0 
.................... void DRDY_interrupt_handler() 
0055A:  PUSH    42
0055C:  PUSH    36
0055E:  PUSH    54
00560:  MOV     W0,[W15++]
00562:  MOV     #2,W0
00564:  REPEAT  #C
00566:  MOV     [W0++],[W15++]
.................... { 
....................    CLEAR_INTERRUPT(INT_EXT1); 
00568:  BCLR.B  802.4
....................    ENABLE_INTERRUPTS(INT_EXT1); 
0056A:  BSET.B  822.4
....................    printf("Waiting for Data Clock \n\r"); 
0056C:  MOV     #0,W1
0056E:  MOV     W1,W0
00570:  CLR.B   1
00572:  CALL    230
00576:  INC     W1,W1
00578:  BTSC.B  223.1
0057A:  BRA     578
0057C:  MOV     W0,224
0057E:  MOV     #18,W0
00580:  CPSGT   W1,W0
00582:  BRA     56E
.................... } 
....................  
00584:  BCLR.B  800.0
00586:  MOV     #1A,W0
00588:  REPEAT  #C
0058A:  MOV     [--W15],[W0--]
0058C:  MOV     [--W15],W0
0058E:  POP     54
00590:  POP     36
00592:  POP     42
00594:  RETFIE  
.................... #INT_DMA0 
.................... void DMA_interrupt_handler() 
*
0064C:  PUSH    42
0064E:  PUSH    36
00650:  PUSH    54
00652:  MOV     W0,[W15++]
00654:  MOV     #2,W0
00656:  REPEAT  #C
00658:  MOV     [W0++],[W15++]
.................... { 
....................    printf("DMA Transfer Complete \n\r"); 
0065A:  MOV     #0,W1
0065C:  MOV     W1,W0
0065E:  CLR.B   1
00660:  CALL    256
00664:  INC     W1,W1
00666:  BTSC.B  223.1
00668:  BRA     666
0066A:  MOV     W0,224
0066C:  MOV     #17,W0
0066E:  CPSGT   W1,W0
00670:  BRA     65C
....................    printf("Channel[0][0] is: %u \n\r", channel[0][0]);  
00672:  MOV     #0,W1
00674:  MOV     W1,W0
00676:  CLR.B   1
00678:  CALL    27C
0067C:  INC     W1,W1
0067E:  BTSC.B  223.1
00680:  BRA     67E
00682:  MOV     W0,224
00684:  MOV     #11,W0
00686:  CPSGT   W1,W0
00688:  BRA     674
0068A:  MOV.B   1002,W0L
0068C:  CLR.B   1
0068E:  MOV     #0,W4
00690:  CALL    596
00694:  BTSC.B  223.1
00696:  BRA     694
00698:  MOV     #20,W4
0069A:  MOV     W4,224
0069C:  BTSC.B  223.1
0069E:  BRA     69C
006A0:  MOV     #A,W4
006A2:  MOV     W4,224
006A4:  BTSC.B  223.1
006A6:  BRA     6A4
006A8:  MOV     #D,W4
006AA:  MOV     W4,224
....................  //  clear_channel(); 
006AC:  BCLR.B  800.4
006AE:  MOV     #1A,W0
006B0:  REPEAT  #C
006B2:  MOV     [--W15],[W0--]
006B4:  MOV     [--W15],W0
006B6:  POP     54
006B8:  POP     36
006BA:  POP     42
006BC:  RETFIE  
.................... } 
....................  
....................  
.................... void main(){ 
*
00712:  MOV     #7F80,W15
00714:  MOV     #7FFF,W0
00716:  MOV     W0,20
00718:  NOP     
0071A:  BSET.B  8C1.7
0071C:  DISI    #6
0071E:  MOV     #742,W1
00720:  MOV     #46,W2
00722:  MOV     #57,W3
00724:  MOV.B   W2L,[W1]
00726:  MOV.B   W3L,[W1]
00728:  BCLR.B  742.6
0072A:  MOV     #2600,W0
0072C:  MOV     W0,6A0
0072E:  MOV     #2C,W0
00730:  MOV     W0,6C4
00732:  MOV     #100,W0
00734:  MOV     W0,688
00736:  DISI    #6
00738:  MOV     #742,W1
0073A:  MOV     #46,W2
0073C:  MOV     #57,W3
0073E:  MOV.B   W2L,[W1]
00740:  MOV.B   W3L,[W1]
00742:  BSET.B  742.6
00744:  CLR     744
00746:  MOV     #36,W4
00748:  MOV     W4,746
0074A:  DISI    #E
0074C:  MOV     #103,W0
0074E:  MOV     #743,W1
00750:  MOV     #78,W2
00752:  MOV     #9A,W3
00754:  MOV.B   W2L,[W1]
00756:  MOV.B   W3L,[W1]
00758:  MOV.B   W0L,743
0075A:  LSR     W0,#8,W0
0075C:  MOV     #742,W1
0075E:  MOV     #46,W2
00760:  MOV     #57,W3
00762:  MOV.B   W2L,[W1]
00764:  MOV.B   W3L,[W1]
00766:  MOV.B   W0L,[W1]
00768:  MOV     #8000,W4
0076A:  MOV     W4,220
0076C:  MOV     #400,W4
0076E:  MOV     W4,222
00770:  BCLR.B  220.3
00772:  MOV     #25,W4
00774:  MOV     W4,228
00776:  CLR     101C
00778:  CLR     101E
0077A:  CLR     1020
0077C:  BCLR.B  1022.0
0077E:  CLR     E0E
00780:  CLR     E1E
00782:  CLR     1000
.................... //#BIT INT0EP = 0x08C2.0; 
....................    delay_ms(500); 
00784:  MOV     #1F4,W0
00786:  CALL    6BE
....................    EXT_INT_EDGE(L_TO_H); 
0078A:  BCLR.B  8C2.0
....................    int Value; 
....................     
.................... //   INT0EP = 1; // negative edge 
....................     
....................    CLEAR_INTERRUPT(INT_EXT0); 
0078C:  BCLR.B  800.0
....................    ENABLE_INTERRUPTS(INT_EXT0); 
0078E:  BSET.B  820.0
....................    CLEAR_INTERRUPT(INT_DMA0); 
00790:  BCLR.B  800.4
....................    ENABLE_INTERRUPTS(INT_DMA0); 
00792:  BSET.B  820.4
....................  
....................   // ENABLE_INTERRUPTS(INTR_NORMAL); 
....................    ENABLE_INTERRUPTS(INTR_GLOBAL); 
00794:  BSET.B  8C3.7
....................     
....................    setup_dma(0,DMA_OUT_UART1,DMA_BYTE);    
00796:  MOV.B   #60,W0L
00798:  MOV.B   W0L,B01
0079A:  MOV.B   #C,W0L
0079C:  MOV.B   W0L,B02
0079E:  MOV     #224,W4
007A0:  MOV     W4,B0C
....................    //dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................    int i = 0; 
007A2:  CLR     1026
....................    //initialize the array 
....................    clear_channel(); 
007A4:  CALL    6DE
....................     
....................    printf("Test1 \n\r"); 
007A8:  MOV     #0,W1
007AA:  MOV     W1,W0
007AC:  CLR.B   1
007AE:  CALL    2A0
007B2:  INC     W1,W1
007B4:  BTSC.B  223.1
007B6:  BRA     7B4
007B8:  MOV     W0,224
007BA:  MOV     #7,W0
007BC:  CPSGT   W1,W0
007BE:  BRA     7AA
.................... //!  while(count != 5){ 
.................... //!   output_high(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   output_low(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   printf("Hello, World! \n\r"); 
.................... //!   count++; 
.................... //!   } 
....................    delay_ms(200); 
007C0:  MOV     #C8,W0
007C2:  CALL    6BE
007C6:  PUSH    8C2
007C8:  BCLR.B  8C3.7
....................    display_matrix(); 
007CA:  CALL    3E2
007CE:  POP     8C2
....................    while(1) 
....................    { 
....................       delay_ms(2000); 
007D0:  MOV     #7D0,W0
007D2:  CALL    6BE
....................       printf("No \n\r"); 
007D6:  MOV     #0,W1
007D8:  MOV     W1,W0
007DA:  CLR.B   1
007DC:  CALL    2B6
007E0:  INC     W1,W1
007E2:  BTSC.B  223.1
007E4:  BRA     7E2
007E6:  MOV     W0,224
007E8:  MOV     #4,W0
007EA:  CPSGT   W1,W0
007EC:  BRA     7D8
007EE:  GOTO    7D0
....................       //Value = dma_status(0); 
....................       //printf("DMA status: %u \n\r", Value); 
....................      // dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................       
....................    } 
....................    //printf("ch0 is:%u \n\r",ch0); 
....................    int support = getenv("DMA"); 
007F2:  MOV     #1,W4
007F4:  MOV     W4,1028
....................    printf("DMA Valid: %u", support); 
007F6:  MOV     #0,W1
007F8:  MOV     W1,W0
007FA:  CLR.B   1
007FC:  CALL    2C8
00800:  INC     W1,W1
00802:  BTSC.B  223.1
00804:  BRA     802
00806:  MOV     W0,224
00808:  MOV     #A,W0
0080A:  CPSGT   W1,W0
0080C:  BRA     7F8
0080E:  MOV     1028,W0
00810:  MOV     #0,W4
00812:  CALL    596
.................... } 
*
00816:  PWRSAV  #0

Configuration Fuses:
   Word  3L: FFCF   ICSP1 NOJTAG NODEBUG
          H: 0000  
   Word  4L: FFFF   NOALTI2C1 NOALTI2C2 WDTWIN_25%
          H: 0000  
   Word  5L: FF7F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: 0000  
   Word  6L: FF7A   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  7L: FFF8   FRC IESO
          H: 0000  
   Word  8L: FFFF   NOWRT NOPROTECT
          H: 0000  
   Word  9L: FFFF  
          H: 0000  
   Word 10L: FFFF  
          H: 0000  
