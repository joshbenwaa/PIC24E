CCS PCD C Compiler, Version 5.071d, 1               10-Jul-17 17:31
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\joshb\OneDrive - St. Cloud State University\PIC24E\DataReading_Working_7_10\DataReading_Working_7_10.lst

               ROM used:   1772 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   162 (0%) at main() level
                           168 (1%) worst case
               Stack used: 70 locations (18 in main + 52 for interrupts)
               Stack size: 128

*
00000:  GOTO    5F0
*
00014:  DATA    D8,04,00
*
0001C:  DATA    14,05,00
*
0003C:  DATA    80,03,00
.................... #include <24EP256GP202.h> 
.................... //////////// Standard Header file for the PIC24EP256GP202 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24EP256GP202 
*
00200:  CLR     54
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    25,75,00
0020E:  DATA    20,20,00
00210:  DATA    20,20,00
00212:  DATA    20,00,00
00214:  CLR     54
00216:  MOV     #220,W3
00218:  ADD     W3,W0,W0
0021A:  TBLRDL.B[W0],W0L
0021C:  CLR.B   1
0021E:  RETURN  
00220:  DATA    44,61,00
00222:  DATA    74,61,00
00224:  DATA    20,52,00
00226:  DATA    65,61,00
00228:  DATA    64,69,00
0022A:  DATA    6E,67,00
0022C:  DATA    20,0A,00
0022E:  DATA    0D,00,00
00230:  CLR     54
00232:  MOV     #23C,W3
00234:  ADD     W3,W0,W0
00236:  TBLRDL.B[W0],W0L
00238:  CLR.B   1
0023A:  RETURN  
0023C:  DATA    47,65,00
0023E:  DATA    74,73,00
00240:  DATA    20,68,00
00242:  DATA    65,72,00
00244:  DATA    65,20,00
00246:  DATA    0A,0D,00
00248:  DATA    00,00,00
0024A:  CLR     54
0024C:  MOV     #256,W3
0024E:  ADD     W3,W0,W0
00250:  TBLRDL.B[W0],W0L
00252:  CLR.B   1
00254:  RETURN  
00256:  DATA    43,6F,00
00258:  DATA    6C,73,00
0025A:  DATA    20,25,00
0025C:  DATA    75,20,00
0025E:  DATA    0A,0D,00
00260:  DATA    00,00,00
00262:  CLR     54
00264:  MOV     #26E,W3
00266:  ADD     W3,W0,W0
00268:  TBLRDL.B[W0],W0L
0026A:  CLR.B   1
0026C:  RETURN  
0026E:  DATA    57,61,00
00270:  DATA    69,74,00
00272:  DATA    69,6E,00
00274:  DATA    67,20,00
00276:  DATA    66,6F,00
00278:  DATA    72,20,00
0027A:  DATA    44,61,00
0027C:  DATA    74,61,00
0027E:  DATA    20,43,00
00280:  DATA    6C,6F,00
00282:  DATA    63,6B,00
00284:  DATA    20,0A,00
00286:  DATA    0D,00,00
00288:  CLR     54
0028A:  MOV     #294,W3
0028C:  ADD     W3,W0,W0
0028E:  TBLRDL.B[W0],W0L
00290:  CLR.B   1
00292:  RETURN  
00294:  DATA    54,65,00
00296:  DATA    73,74,00
00298:  DATA    31,20,00
0029A:  DATA    0A,0D,00
0029C:  DATA    00,00,00
0029E:  CLR     54
002A0:  MOV     #2AA,W3
002A2:  ADD     W3,W0,W0
002A4:  TBLRDL.B[W0],W0L
002A6:  CLR.B   1
002A8:  RETURN  
002AA:  DATA    4E,6F,00
002AC:  DATA    20,0A,00
002AE:  DATA    0D,00,00
002B0:  CLR     54
002B2:  MOV     #2BC,W3
002B4:  ADD     W3,W0,W0
002B6:  TBLRDL.B[W0],W0L
002B8:  CLR.B   1
002BA:  RETURN  
002BC:  DATA    44,4D,00
002BE:  DATA    41,20,00
002C0:  DATA    56,61,00
002C2:  DATA    6C,69,00
002C4:  DATA    64,3A,00
002C6:  DATA    20,25,00
002C8:  DATA    75,00,00
002CA:  MOV     W5,[W15++]
002CC:  MOV     #C,W5
002CE:  REPEAT  #3
002D0:  MOV     [W5++],[W15++]
002D2:  MOV     W0,W7
002D4:  MOV     W4,W9
002D6:  BCLR    W4.F
002D8:  CP0     W4
002DA:  BRA     NZ,2E8
002DC:  BTSC    W9.F
002DE:  BRA     2E4
002E0:  MOV     #0,W5
002E2:  BRA     306
002E4:  MOV     #0,W5
002E6:  BRA     306
002E8:  SUB.B   W4L,#6,W5L
002EA:  BRA     NC,304
002EC:  MOV     #30,W0
002EE:  BTSS    W9.F
002F0:  MOV     #20,W0
002F2:  MOV     W0,[W15++]
002F4:  BTSC.B  223.1
002F6:  BRA     2F4
002F8:  MOV     W0,224
002FA:  MOV     [--W15],W0
002FC:  DEC     W5,W5
002FE:  BRA     NN,2F2
00300:  MOV     #5,W5
00302:  BRA     306
00304:  MOV     W4,W5
00306:  MOV     #6,W4
00308:  BSET    W5.E
0030A:  BTSC    W9.F
0030C:  BSET    W5.F
0030E:  MOV     #2710,W8
00310:  REPEAT  #11
00312:  DIV.U   W7,W8
00314:  CALL    348
00318:  MOV     W1,W7
0031A:  MOV     #3E8,W8
0031C:  REPEAT  #11
0031E:  DIV.U   W7,W8
00320:  CALL    348
00324:  MOV     W1,W7
00326:  MOV     #64,W8
00328:  REPEAT  #11
0032A:  DIV.U   W7,W8
0032C:  CALL    348
00330:  MOV     W1,W7
00332:  MOV     #A,W8
00334:  REPEAT  #11
00336:  DIV.U   W7,W8
00338:  CALL    348
0033C:  MOV     #30,W0
0033E:  ADD.B   W1L,W0L,W0L
00340:  BTSC.B  223.1
00342:  BRA     340
00344:  MOV     W0,224
00346:  BRA     376
00348:  MOV     #30,W6
0034A:  CP0     W0
0034C:  BRA     NZ,36A
0034E:  BTSS    W5.E
00350:  BRA     36C
00352:  DEC     W4,W4
00354:  CP.B    W4L,W5L
00356:  BRA     Z,35C
00358:  BTSC.B  42.0
0035A:  RETURN  
0035C:  CP0     W0
0035E:  BRA     NZ,36A
00360:  BTSS    W5.E
00362:  BRA     36C
00364:  BTSS    W5.F
00366:  MOV     #20,W6
00368:  BRA     36C
0036A:  BCLR    W5.E
0036C:  ADD.B   W6L,W0L,W0L
0036E:  BTSC.B  223.1
00370:  BRA     36E
00372:  MOV     W0,224
00374:  RETURN  
00376:  MOV     #12,W5
00378:  REPEAT  #3
0037A:  MOV     [--W15],[W5--]
0037C:  MOV     [--W15],W5
0037E:  RETURN  
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#device icd=true 
.................... //#FUSES FRC_PLL 
.................... #FUSES HS,PR_PLL 
....................  
.................... #use delay(xtal = 10MHZ, clock = 140MHz) 
*
00534:  CP0     W0
00536:  BTSC.B  42.1
00538:  BRA     552
0053A:  REPEAT  #116B
0053C:  NOP     
0053E:  REPEAT  #3FFE
00540:  NOP     
00542:  REPEAT  #3FFE
00544:  NOP     
00546:  REPEAT  #3FFE
00548:  NOP     
0054A:  REPEAT  #3FFE
0054C:  NOP     
0054E:  DEC     W0,W0
00550:  BRA     NZ,53A
00552:  RETURN  
....................  
.................... #pin_select U1TX = PIN_B11 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232(UART1, baud = 115200, stream = UART_PORT1) 
.................... //#USE RS232(STREAM=UART1, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500, XMIT = PIN_B14, RCV = PIN_B15 )) 
.................... #BANK_DMA  unsigned int8 channel[8][3]; 
.................... #pin_select INT1 = PIN_B6 
.................... //#define SPI_CS PIN_B6 
.................... //unsigned int32 channel[8];   
.................... //int channel[8]; 
....................  unsigned int rows = 0, cols = 0, bitCount =  0; 
.................... //int j = 0; 
.................... //#DEFINE ENABLE_INTERRUPTS(PIN_B11); 
....................  
.................... void clear_channel() 
00554:  MOV     W5,[W15++]
00556:  CLR     1022
00558:  CLR     1024
.................... { 
....................    int i = 0, k = 0; 
....................    while(i < 8){ 
0055A:  MOV     1022,W4
0055C:  CP      W4,#8
0055E:  BRA     GE,584
....................       while(k < 3){ 
00560:  MOV     1024,W4
00562:  CP      W4,#3
00564:  BRA     GE,57C
....................          channel[i][k] = 0; 
00566:  MOV     1022,W4
00568:  MUL.UU  W4,#3,W0
0056A:  MOV     W0,W5
0056C:  MOV     W5,W0
0056E:  ADD     1024,W0
00570:  MOV     #1002,W4
00572:  ADD     W0,W4,W5
00574:  CLR.B   [W5]
....................          k++; 
00576:  INC     1024
00578:  GOTO    560
....................       } 
....................       k = 0; 
0057C:  CLR     1024
....................       i++; 
0057E:  INC     1022
00580:  GOTO    55A
....................    } 
00584:  MOV     [--W15],W5
00586:  RETURN  
.................... } 
....................  
.................... void display_matrix(void) 
00588:  MOV     W5,[W15++]
0058A:  CLR     1022
0058C:  CLR     1024
.................... { 
....................    int row = 0, columns = 0; 
....................    for (row=0; row<8; row++) 
0058E:  CLR     1022
00590:  MOV     1022,W4
00592:  CP      W4,#8
00594:  BRA     GE,5EC
....................    { 
....................     for(columns=0; columns<3; columns++) 
00596:  CLR     1024
00598:  MOV     1024,W4
0059A:  CP      W4,#3
0059C:  BRA     GE,5D6
....................         { 
....................          printf("%u     ", channel[row][columns]); 
0059E:  MOV     1022,W4
005A0:  MUL.UU  W4,#3,W0
005A2:  MOV     W0,W5
005A4:  MOV     W5,W0
005A6:  ADD     1024,W0
005A8:  MOV     #1002,W4
005AA:  ADD     W0,W4,W0
005AC:  MOV.B   [W0],W5L
005AE:  MOV.B   W5L,W0L
005B0:  CLR.B   1
005B2:  MOV     #0,W4
005B4:  CALL    2CA
005B8:  MOV     #2,W1
005BA:  MOV     W1,W0
005BC:  CLR.B   1
005BE:  CALL    200
005C2:  INC     W1,W1
005C4:  BTSC.B  223.1
005C6:  BRA     5C4
005C8:  MOV     W0,224
005CA:  MOV     #6,W0
005CC:  CPSGT   W1,W0
005CE:  BRA     5BA
005D0:  INC     1024
005D2:  GOTO    598
....................         } 
....................       printf("\n\r"); 
005D6:  BTSC.B  223.1
005D8:  BRA     5D6
005DA:  MOV     #A,W4
005DC:  MOV     W4,224
005DE:  BTSC.B  223.1
005E0:  BRA     5DE
005E2:  MOV     #D,W4
005E4:  MOV     W4,224
005E6:  INC     1022
005E8:  GOTO    590
....................    } 
005EC:  MOV     [--W15],W5
005EE:  RETURN  
.................... } 
....................  
.................... #INT_EXT1 
.................... void DCLK_interrupt_handler() 
*
00380:  PUSH    42
00382:  PUSH    36
00384:  PUSH    54
00386:  MOV     W0,[W15++]
00388:  MOV     #2,W0
0038A:  REPEAT  #C
0038C:  MOV     [W0++],[W15++]
.................... {         
....................          while(rows <= 7){ 
0038E:  MOV     101A,W4
00390:  CP      W4,#7
00392:  BRA     GTU,3B0
....................          //shift bits left for next inputDMA0   DMA channel 0 transfer complete 
....................             channel[rows][cols] <<= 1; 
00394:  MOV     101A,W4
00396:  MUL.UU  W4,#3,W0
00398:  MOV     W0,W5
0039A:  MOV     W5,W0
0039C:  ADD     101C,W0
0039E:  MOV     #1002,W4
003A0:  ADD     W0,W4,W5
003A2:  MOV.B   [W5],W0L
003A4:  CLR.B   1
003A6:  SL      W0,#1,W0
003A8:  MOV.B   W0L,[W5]
....................             rows++; 
003AA:  INC     101A
003AC:  GOTO    38E
....................          } 
....................           rows = 0; 
003B0:  CLR     101A
....................           bitCount++; 
003B2:  INC     101E
....................          //Accept inputs 1 bit at a time 
....................          channel[0][cols] += input(PIN_B0); 
003B4:  MOV     #1002,W4
003B6:  MOV     101C,W3
003B8:  ADD     W3,W4,W5
003BA:  BSET.B  E10.0
003BC:  CLR     W0
003BE:  BTSC.B  E12.0
003C0:  INC     W0,W0
003C2:  ADD.B   W0L,[W5],[W5]
....................          channel[1][cols] += input(PIN_B1); 
003C4:  MOV     #1005,W0
003C6:  ADD     101C,W0
003C8:  MOV     W0,W5
003CA:  BSET.B  E10.1
003CC:  CLR     W0
003CE:  BTSC.B  E12.1
003D0:  INC     W0,W0
003D2:  ADD.B   W0L,[W5],[W5]
....................          channel[2][cols] += input(PIN_B2); 
003D4:  MOV     #1008,W0
003D6:  ADD     101C,W0
003D8:  MOV     W0,W5
003DA:  BSET.B  E10.2
003DC:  CLR     W0
003DE:  BTSC.B  E12.2
003E0:  INC     W0,W0
003E2:  ADD.B   W0L,[W5],[W5]
....................          channel[3][cols] += input(PIN_B3); 
003E4:  MOV     #100B,W0
003E6:  ADD     101C,W0
003E8:  MOV     W0,W5
003EA:  BSET.B  E10.3
003EC:  CLR     W0
003EE:  BTSC.B  E12.3
003F0:  INC     W0,W0
003F2:  ADD.B   W0L,[W5],[W5]
....................          channel[4][cols] += input(PIN_B4); 
003F4:  MOV     #100E,W0
003F6:  ADD     101C,W0
003F8:  MOV     W0,W5
003FA:  BSET.B  E10.4
003FC:  CLR     W0
003FE:  BTSC.B  E12.4
00400:  INC     W0,W0
00402:  ADD.B   W0L,[W5],[W5]
....................          channel[5][cols] += input(PIN_B5); 
00404:  MOV     #1011,W0
00406:  ADD     101C,W0
00408:  MOV     W0,W5
0040A:  BSET.B  E10.5
0040C:  CLR     W0
0040E:  BTSC.B  E12.5
00410:  INC     W0,W0
00412:  ADD.B   W0L,[W5],[W5]
....................          channel[6][cols] += input(PIN_B8); //B6 Used by interrupt 
00414:  MOV     #1014,W0
00416:  ADD     101C,W0
00418:  MOV     W0,W5
0041A:  BSET.B  E11.0
0041C:  CLR     W0
0041E:  BTSC.B  E13.0
00420:  INC     W0,W0
00422:  ADD.B   W0L,[W5],[W5]
....................          channel[7][cols] += input(PIN_B9); //B7 Used by interrupt 
00424:  MOV     #1017,W0
00426:  ADD     101C,W0
00428:  MOV     W0,W5
0042A:  BSET.B  E11.1
0042C:  CLR     W0
0042E:  BTSC.B  E13.1
00430:  INC     W0,W0
00432:  ADD.B   W0L,[W5],[W5]
....................          //Possible take whole port at one time??? 
....................          //inputPortB = input_b(); 
....................         // printf("Bitcount = %u \n\r", bitCount);          
....................          printf("Data Reading \n\r"); 
00434:  MOV     #0,W1
00436:  MOV     W1,W0
00438:  CLR.B   1
0043A:  CALL    214
0043E:  INC     W1,W1
00440:  BTSC.B  223.1
00442:  BRA     440
00444:  MOV     W0,224
00446:  MOV     #E,W0
00448:  CPSGT   W1,W0
0044A:  BRA     436
....................          if (bitCount == 8){ 
0044C:  MOV     101E,W4
0044E:  CP      W4,#8
00450:  BRA     NZ,4C6
....................             if(cols == 2){ 
00452:  MOV     101C,W4
00454:  CP      W4,#2
00456:  BRA     NZ,476
....................                printf("Gets here \n\r" ); 
00458:  MOV     #0,W1
0045A:  MOV     W1,W0
0045C:  CLR.B   1
0045E:  CALL    230
00462:  INC     W1,W1
00464:  BTSC.B  223.1
00466:  BRA     464
00468:  MOV     W0,224
0046A:  MOV     #B,W0
0046C:  CPSGT   W1,W0
0046E:  BRA     45A
....................                cols = 0; 
00470:  CLR     101C
....................              //  display_matrix(); 
....................             } 
00472:  GOTO    478
....................             else{ 
....................             cols++; 
00476:  INC     101C
....................             } 
....................             dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel, 24); 
00478:  BCLR.B  B01.7
0047A:  MOV.B   #1,W0L
0047C:  MOV.B   W0L,B00
0047E:  MOV     #1002,W4
00480:  MOV     W4,B04
00482:  CLR     B06
00484:  MOV     #18,W4
00486:  MOV     W4,B0E
00488:  BSET.B  B01.7
0048A:  BSET.B  B03.7
....................             bitCount = 0; 
0048C:  CLR     101E
....................             printf("Cols %u \n\r", cols); 
0048E:  MOV     #0,W1
00490:  MOV     W1,W0
00492:  CLR.B   1
00494:  CALL    24A
00498:  INC     W1,W1
0049A:  BTSC.B  223.1
0049C:  BRA     49A
0049E:  MOV     W0,224
004A0:  MOV     #4,W0
004A2:  CPSGT   W1,W0
004A4:  BRA     490
004A6:  MOV     101C,W0
004A8:  MOV     #0,W4
004AA:  CALL    2CA
004AE:  BTSC.B  223.1
004B0:  BRA     4AE
004B2:  MOV     #20,W4
004B4:  MOV     W4,224
004B6:  BTSC.B  223.1
004B8:  BRA     4B6
004BA:  MOV     #A,W4
004BC:  MOV     W4,224
004BE:  BTSC.B  223.1
004C0:  BRA     4BE
004C2:  MOV     #D,W4
004C4:  MOV     W4,224
....................          } 
....................           
....................           
....................           
.................... //!   else{ 
.................... //!      printf("24 bits\n\r"); 
.................... //!      bitCount = 0; 
.................... //!      dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0]); 
.................... //!   } 
.................... } 
....................  
....................  
004C6:  BCLR.B  802.4
004C8:  MOV     #1A,W0
004CA:  REPEAT  #C
004CC:  MOV     [--W15],[W0--]
004CE:  MOV     [--W15],W0
004D0:  POP     54
004D2:  POP     36
004D4:  POP     42
004D6:  RETFIE  
.................... #INT_EXT0 
.................... void DRDY_interrupt_handler() 
004D8:  PUSH    42
004DA:  PUSH    36
004DC:  PUSH    54
004DE:  MOV     W0,[W15++]
004E0:  MOV     #2,W0
004E2:  REPEAT  #C
004E4:  MOV     [W0++],[W15++]
.................... { 
....................    CLEAR_INTERRUPT(INT_EXT1); 
004E6:  BCLR.B  802.4
....................    ENABLE_INTERRUPTS(INT_EXT1); 
004E8:  BSET.B  822.4
....................    printf("Waiting for Data Clock \n\r"); 
004EA:  MOV     #0,W1
004EC:  MOV     W1,W0
004EE:  CLR.B   1
004F0:  CALL    262
004F4:  INC     W1,W1
004F6:  BTSC.B  223.1
004F8:  BRA     4F6
004FA:  MOV     W0,224
004FC:  MOV     #18,W0
004FE:  CPSGT   W1,W0
00500:  BRA     4EC
.................... } 
....................  
00502:  BCLR.B  800.0
00504:  MOV     #1A,W0
00506:  REPEAT  #C
00508:  MOV     [--W15],[W0--]
0050A:  MOV     [--W15],W0
0050C:  POP     54
0050E:  POP     36
00510:  POP     42
00512:  RETFIE  
.................... #INT_DMA0 
.................... void DMA_interrupt_handler() 
00514:  PUSH    42
00516:  PUSH    36
00518:  PUSH    54
0051A:  MOV     W0,[W15++]
0051C:  MOV     #2,W0
0051E:  REPEAT  #C
00520:  MOV     [W0++],[W15++]
.................... { 
....................  //  printf("DMA Transfer Complete \n\r"); 
....................   // printf("Channel[0][0] is: %u \n\r", channel[0][0]);  
....................  //  clear_channel(); 
....................    
00522:  BCLR.B  800.4
00524:  MOV     #1A,W0
00526:  REPEAT  #C
00528:  MOV     [--W15],[W0--]
0052A:  MOV     [--W15],W0
0052C:  POP     54
0052E:  POP     36
00530:  POP     42
00532:  RETFIE  
.................... } 
....................  
....................  
.................... void main(){ 
*
005F0:  MOV     #7F80,W15
005F2:  MOV     #7FFF,W0
005F4:  MOV     W0,20
005F6:  NOP     
005F8:  BSET.B  8C1.7
005FA:  DISI    #6
005FC:  MOV     #742,W1
005FE:  MOV     #46,W2
00600:  MOV     #57,W3
00602:  MOV.B   W2L,[W1]
00604:  MOV.B   W3L,[W1]
00606:  BCLR.B  742.6
00608:  MOV     #2600,W0
0060A:  MOV     W0,6A0
0060C:  MOV     #2C,W0
0060E:  MOV     W0,6C4
00610:  MOV     #100,W0
00612:  MOV     W0,688
00614:  DISI    #6
00616:  MOV     #742,W1
00618:  MOV     #46,W2
0061A:  MOV     #57,W3
0061C:  MOV.B   W2L,[W1]
0061E:  MOV.B   W3L,[W1]
00620:  BSET.B  742.6
00622:  CLR     744
00624:  MOV     #36,W4
00626:  MOV     W4,746
00628:  DISI    #E
0062A:  MOV     #103,W0
0062C:  MOV     #743,W1
0062E:  MOV     #78,W2
00630:  MOV     #9A,W3
00632:  MOV.B   W2L,[W1]
00634:  MOV.B   W3L,[W1]
00636:  MOV.B   W0L,743
00638:  LSR     W0,#8,W0
0063A:  MOV     #742,W1
0063C:  MOV     #46,W2
0063E:  MOV     #57,W3
00640:  MOV.B   W2L,[W1]
00642:  MOV.B   W3L,[W1]
00644:  MOV.B   W0L,[W1]
00646:  MOV     #8000,W4
00648:  MOV     W4,220
0064A:  MOV     #400,W4
0064C:  MOV     W4,222
0064E:  BCLR.B  220.3
00650:  MOV     #25,W4
00652:  MOV     W4,228
00654:  CLR     101A
00656:  CLR     101C
00658:  CLR     101E
0065A:  CLR     E0E
0065C:  CLR     E1E
0065E:  CLR     1000
.................... //#BIT INT0EP = 0x08C2.0; 
....................    delay_ms(500); 
00660:  MOV     #1F4,W0
00662:  CALL    534
....................    EXT_INT_EDGE(L_TO_H); 
00666:  BCLR.B  8C2.0
....................     
.................... //   INT0EP = 1; // negative edge 
....................     
....................    CLEAR_INTERRUPT(INT_EXT0); 
00668:  BCLR.B  800.0
....................    ENABLE_INTERRUPTS(INT_EXT0); 
0066A:  BSET.B  820.0
....................    CLEAR_INTERRUPT(INT_DMA0); 
0066C:  BCLR.B  800.4
....................    ENABLE_INTERRUPTS(INT_DMA0); 
0066E:  BSET.B  820.4
....................  
....................   // ENABLE_INTERRUPTS(INTR_NORMAL); 
....................    ENABLE_INTERRUPTS(INTR_GLOBAL); 
00670:  BSET.B  8C3.7
....................     
....................    setup_dma(0,DMA_OUT_UART1,DMA_BYTE);    
00672:  MOV.B   #60,W0L
00674:  MOV.B   W0L,B01
00676:  MOV.B   #C,W0L
00678:  MOV.B   W0L,B02
0067A:  MOV     #224,W4
0067C:  MOV     W4,B0C
....................    //dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................    //initialize the array 
....................    clear_channel(); 
0067E:  CALL    554
....................     
....................    printf("Test1 \n\r"); 
00682:  MOV     #0,W1
00684:  MOV     W1,W0
00686:  CLR.B   1
00688:  CALL    288
0068C:  INC     W1,W1
0068E:  BTSC.B  223.1
00690:  BRA     68E
00692:  MOV     W0,224
00694:  MOV     #7,W0
00696:  CPSGT   W1,W0
00698:  BRA     684
.................... //!  while(count != 5){ 
.................... //!   output_high(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   output_low(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   printf("Hello, World! \n\r"); 
.................... //!   count++; 
.................... //!   } 
....................    delay_ms(200); 
0069A:  MOV     #C8,W0
0069C:  CALL    534
....................    display_matrix(); 
006A0:  CALL    588
....................    while(1) 
....................    { 
....................       delay_ms(2000); 
006A4:  MOV     #7D0,W0
006A6:  CALL    534
....................       printf("No \n\r"); 
006AA:  MOV     #0,W1
006AC:  MOV     W1,W0
006AE:  CLR.B   1
006B0:  CALL    29E
006B4:  INC     W1,W1
006B6:  BTSC.B  223.1
006B8:  BRA     6B6
006BA:  MOV     W0,224
006BC:  MOV     #4,W0
006BE:  CPSGT   W1,W0
006C0:  BRA     6AC
006C2:  GOTO    6A4
....................       //Value = dma_status(0); 
....................       //printf("DMA status: %u \n\r", Value); 
....................      // dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................       
....................    } 
....................    //printf("ch0 is:%u \n\r",ch0); 
....................    int support = getenv("DMA"); 
006C6:  MOV     #1,W4
006C8:  MOV     W4,1020
....................    printf("DMA Valid: %u", support); 
006CA:  MOV     #0,W1
006CC:  MOV     W1,W0
006CE:  CLR.B   1
006D0:  CALL    2B0
006D4:  INC     W1,W1
006D6:  BTSC.B  223.1
006D8:  BRA     6D6
006DA:  MOV     W0,224
006DC:  MOV     #A,W0
006DE:  CPSGT   W1,W0
006E0:  BRA     6CC
006E2:  MOV     1020,W0
006E4:  MOV     #0,W4
006E6:  CALL    2CA
.................... } 
*
006EA:  PWRSAV  #0

Configuration Fuses:
   Word  3L: FFCF   ICSP1 NOJTAG NODEBUG
          H: 0000  
   Word  4L: FFFF   NOALTI2C1 NOALTI2C2 WDTWIN_25%
          H: 0000  
   Word  5L: FF7F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: 0000  
   Word  6L: FF7A   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  7L: FFF8   FRC IESO
          H: 0000  
   Word  8L: FFFF   NOWRT NOPROTECT
          H: 0000  
   Word  9L: FFFF  
          H: 0000  
   Word 10L: FFFF  
          H: 0000  
