CCS PCD C Compiler, Version 5.071d, 1               10-Jul-17 14:53
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\joshb\OneDrive - St. Cloud State University\PIC24E\DataReading_Working_7_10\DataReading_Working_7_10.lst

               ROM used:   2070 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   170 (1%) at main() level
                           184 (1%) worst case
               Stack used: 74 locations (18 in main + 56 for interrupts)
               Stack size: 128

*
00000:  GOTO    710
*
00014:  DATA    58,05,00
*
0001C:  DATA    4A,06,00
*
0003C:  DATA    48,04,00
.................... #include <24EP256GP202.h> 
.................... //////////// Standard Header file for the PIC24EP256GP202 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24EP256GP202 
*
00200:  CLR     54
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    25,64,00
0020E:  DATA    20,20,00
00210:  DATA    20,20,00
00212:  DATA    20,00,00
00214:  CLR     54
00216:  MOV     #220,W3
00218:  ADD     W3,W0,W0
0021A:  TBLRDL.B[W0],W0L
0021C:  CLR.B   1
0021E:  RETURN  
00220:  DATA    44,61,00
00222:  DATA    74,61,00
00224:  DATA    20,52,00
00226:  DATA    65,61,00
00228:  DATA    64,69,00
0022A:  DATA    6E,67,00
0022C:  DATA    20,0A,00
0022E:  DATA    0D,00,00
00230:  CLR     54
00232:  MOV     #23C,W3
00234:  ADD     W3,W0,W0
00236:  TBLRDL.B[W0],W0L
00238:  CLR.B   1
0023A:  RETURN  
0023C:  DATA    57,61,00
0023E:  DATA    69,74,00
00240:  DATA    69,6E,00
00242:  DATA    67,20,00
00244:  DATA    66,6F,00
00246:  DATA    72,20,00
00248:  DATA    44,61,00
0024A:  DATA    74,61,00
0024C:  DATA    20,43,00
0024E:  DATA    6C,6F,00
00250:  DATA    63,6B,00
00252:  DATA    20,0A,00
00254:  DATA    0D,00,00
00256:  CLR     54
00258:  MOV     #262,W3
0025A:  ADD     W3,W0,W0
0025C:  TBLRDL.B[W0],W0L
0025E:  CLR.B   1
00260:  RETURN  
00262:  DATA    44,4D,00
00264:  DATA    41,20,00
00266:  DATA    54,72,00
00268:  DATA    61,6E,00
0026A:  DATA    73,66,00
0026C:  DATA    65,72,00
0026E:  DATA    20,43,00
00270:  DATA    6F,6D,00
00272:  DATA    70,6C,00
00274:  DATA    65,74,00
00276:  DATA    65,20,00
00278:  DATA    0A,0D,00
0027A:  DATA    00,00,00
0027C:  CLR     54
0027E:  MOV     #288,W3
00280:  ADD     W3,W0,W0
00282:  TBLRDL.B[W0],W0L
00284:  CLR.B   1
00286:  RETURN  
00288:  DATA    43,68,00
0028A:  DATA    61,6E,00
0028C:  DATA    6E,65,00
0028E:  DATA    6C,5B,00
00290:  DATA    30,5D,00
00292:  DATA    5B,30,00
00294:  DATA    5D,20,00
00296:  DATA    69,73,00
00298:  DATA    3A,20,00
0029A:  DATA    25,75,00
0029C:  DATA    20,0A,00
0029E:  DATA    0D,00,00
002A0:  CLR     54
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    54,65,00
002AE:  DATA    73,74,00
002B0:  DATA    31,20,00
002B2:  DATA    0A,0D,00
002B4:  DATA    00,00,00
002B6:  CLR     54
002B8:  MOV     #2C2,W3
002BA:  ADD     W3,W0,W0
002BC:  TBLRDL.B[W0],W0L
002BE:  CLR.B   1
002C0:  RETURN  
002C2:  DATA    4E,6F,00
002C4:  DATA    20,0A,00
002C6:  DATA    0D,00,00
002C8:  CLR     54
002CA:  MOV     #2D4,W3
002CC:  ADD     W3,W0,W0
002CE:  TBLRDL.B[W0],W0L
002D0:  CLR.B   1
002D2:  RETURN  
002D4:  DATA    44,4D,00
002D6:  DATA    41,20,00
002D8:  DATA    56,61,00
002DA:  DATA    6C,69,00
002DC:  DATA    64,3A,00
002DE:  DATA    20,25,00
002E0:  DATA    75,00,00
002E2:  MOV     W5,[W15++]
002E4:  MOV     #C,W5
002E6:  REPEAT  #3
002E8:  MOV     [W5++],[W15++]
002EA:  BTSS    W0.F
002EC:  BRA     306
002EE:  NEG     W0,W0
002F0:  BSET    W4.8
002F2:  BTSS    W4.F
002F4:  BRA     306
002F6:  MOV     W0,[W15++]
002F8:  MOV     #2D,W0
002FA:  BTSC.B  223.1
002FC:  BRA     2FA
002FE:  MOV     W0,224
00300:  MOV     [--W15],W0
00302:  BCLR    W4.8
00304:  DEC.B   0008
00306:  CLR     W5
00308:  MOV     W0,W7
0030A:  MOV     W4,W9
0030C:  BCLR    W4.F
0030E:  CP0.B   W4L
00310:  BRA     NZ,31E
00312:  BTSC    W9.F
00314:  BRA     31A
00316:  MOV     #0,W5
00318:  BRA     342
0031A:  MOV     #0,W5
0031C:  BRA     342
0031E:  BTSS    W9.8
00320:  SUB.B   W4L,#6,W5L
00322:  BTSC    W9.8
00324:  SUB.B   W4L,#7,W5L
00326:  BRA     NC,340
00328:  MOV     #30,W0
0032A:  BTSS    W9.F
0032C:  MOV     #20,W0
0032E:  MOV     W0,[W15++]
00330:  BTSC.B  223.1
00332:  BRA     330
00334:  MOV     W0,224
00336:  MOV     [--W15],W0
00338:  DEC     W5,W5
0033A:  BRA     NN,32E
0033C:  MOV     #5,W5
0033E:  BRA     342
00340:  MOV     W4,W5
00342:  MOV     #6,W4
00344:  BTSC    W5.8
00346:  INC     W4,W4
00348:  BSET    W5.E
0034A:  BTSC    W9.F
0034C:  BSET    W5.F
0034E:  MOV     #2710,W8
00350:  REPEAT  #11
00352:  DIV.U   W7,W8
00354:  CALL    398
00358:  MOV     W1,W7
0035A:  MOV     #3E8,W8
0035C:  REPEAT  #11
0035E:  DIV.U   W7,W8
00360:  CALL    398
00364:  MOV     W1,W7
00366:  MOV     #64,W8
00368:  REPEAT  #11
0036A:  DIV.U   W7,W8
0036C:  CALL    398
00370:  MOV     W1,W7
00372:  MOV     #A,W8
00374:  REPEAT  #11
00376:  DIV.U   W7,W8
00378:  CALL    398
0037C:  BTSS    W9.8
0037E:  BRA     38A
00380:  MOV     #2D,W0
00382:  BTSC.B  223.1
00384:  BRA     382
00386:  MOV     W0,224
00388:  BCLR    W9.8
0038A:  MOV     #30,W0
0038C:  ADD.B   W1L,W0L,W0L
0038E:  MOV     W0,2A
00390:  BTSC.B  223.1
00392:  BRA     390
00394:  MOV     W0,224
00396:  BRA     3D8
00398:  MOV     #30,W6
0039A:  CP0     W0
0039C:  BRA     NZ,3BA
0039E:  BTSS    W5.E
003A0:  BRA     3CE
003A2:  DEC     W4,W4
003A4:  CP.B    W4L,W5L
003A6:  BRA     Z,3AC
003A8:  BTSC.B  42.0
003AA:  RETURN  
003AC:  CP0     W0
003AE:  BRA     NZ,3BA
003B0:  BTSS    W5.E
003B2:  BRA     3CE
003B4:  BTSS    W5.F
003B6:  MOV     #20,W6
003B8:  BRA     3CE
003BA:  BCLR    W5.E
003BC:  BTSS    W9.8
003BE:  BRA     3CE
003C0:  MOV     W0,W10
003C2:  MOV     #2D,W0
003C4:  BTSC.B  223.1
003C6:  BRA     3C4
003C8:  MOV     W0,224
003CA:  BCLR    W9.8
003CC:  MOV     W10,W0
003CE:  ADD.B   W6L,W0L,W0L
003D0:  BTSC.B  223.1
003D2:  BRA     3D0
003D4:  MOV     W0,224
003D6:  RETURN  
003D8:  MOV     #12,W5
003DA:  REPEAT  #3
003DC:  MOV     [--W15],[W5--]
003DE:  MOV     [--W15],W5
003E0:  RETURN  
*
00594:  MOV     W5,[W15++]
00596:  MOV     #C,W5
00598:  REPEAT  #3
0059A:  MOV     [W5++],[W15++]
0059C:  MOV     W0,W7
0059E:  MOV     W4,W9
005A0:  BCLR    W4.F
005A2:  CP0     W4
005A4:  BRA     NZ,5B2
005A6:  BTSC    W9.F
005A8:  BRA     5AE
005AA:  MOV     #0,W5
005AC:  BRA     5D0
005AE:  MOV     #0,W5
005B0:  BRA     5D0
005B2:  SUB.B   W4L,#6,W5L
005B4:  BRA     NC,5CE
005B6:  MOV     #30,W0
005B8:  BTSS    W9.F
005BA:  MOV     #20,W0
005BC:  MOV     W0,[W15++]
005BE:  BTSC.B  223.1
005C0:  BRA     5BE
005C2:  MOV     W0,224
005C4:  MOV     [--W15],W0
005C6:  DEC     W5,W5
005C8:  BRA     NN,5BC
005CA:  MOV     #5,W5
005CC:  BRA     5D0
005CE:  MOV     W4,W5
005D0:  MOV     #6,W4
005D2:  BSET    W5.E
005D4:  BTSC    W9.F
005D6:  BSET    W5.F
005D8:  MOV     #2710,W8
005DA:  REPEAT  #11
005DC:  DIV.U   W7,W8
005DE:  CALL    612
005E2:  MOV     W1,W7
005E4:  MOV     #3E8,W8
005E6:  REPEAT  #11
005E8:  DIV.U   W7,W8
005EA:  CALL    612
005EE:  MOV     W1,W7
005F0:  MOV     #64,W8
005F2:  REPEAT  #11
005F4:  DIV.U   W7,W8
005F6:  CALL    612
005FA:  MOV     W1,W7
005FC:  MOV     #A,W8
005FE:  REPEAT  #11
00600:  DIV.U   W7,W8
00602:  CALL    612
00606:  MOV     #30,W0
00608:  ADD.B   W1L,W0L,W0L
0060A:  BTSC.B  223.1
0060C:  BRA     60A
0060E:  MOV     W0,224
00610:  BRA     640
00612:  MOV     #30,W6
00614:  CP0     W0
00616:  BRA     NZ,634
00618:  BTSS    W5.E
0061A:  BRA     636
0061C:  DEC     W4,W4
0061E:  CP.B    W4L,W5L
00620:  BRA     Z,626
00622:  BTSC.B  42.0
00624:  RETURN  
00626:  CP0     W0
00628:  BRA     NZ,634
0062A:  BTSS    W5.E
0062C:  BRA     636
0062E:  BTSS    W5.F
00630:  MOV     #20,W6
00632:  BRA     636
00634:  BCLR    W5.E
00636:  ADD.B   W6L,W0L,W0L
00638:  BTSC.B  223.1
0063A:  BRA     638
0063C:  MOV     W0,224
0063E:  RETURN  
00640:  MOV     #12,W5
00642:  REPEAT  #3
00644:  MOV     [--W15],[W5--]
00646:  MOV     [--W15],W5
00648:  RETURN  
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#device icd=true 
.................... //#FUSES FRC_PLL 
.................... #FUSES HS,PR_PLL 
....................  
.................... #use delay(xtal = 10MHZ, clock = 140MHz) 
*
006BC:  CP0     W0
006BE:  BTSC.B  42.1
006C0:  BRA     6DA
006C2:  REPEAT  #116B
006C4:  NOP     
006C6:  REPEAT  #3FFE
006C8:  NOP     
006CA:  REPEAT  #3FFE
006CC:  NOP     
006CE:  REPEAT  #3FFE
006D0:  NOP     
006D2:  REPEAT  #3FFE
006D4:  NOP     
006D6:  DEC     W0,W0
006D8:  BRA     NZ,6C2
006DA:  RETURN  
....................  
.................... #pin_select U1TX = PIN_B11 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232(UART1, baud = 115200, stream = UART_PORT1) 
.................... //#USE RS232(STREAM=UART1, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500, XMIT = PIN_B14, RCV = PIN_B15 )) 
.................... #BANK_DMA  int8 channel[8][3]; 
.................... int count, bitCount = 0; 
.................... #pin_select INT1 = PIN_B6 
.................... //#define SPI_CS PIN_B6 
.................... //unsigned int32 channel[8];   
.................... //int channel[8]; 
.................... int rows = 0, cols = 0 ; 
.................... int1 flag = 0; 
.................... //int j = 0; 
.................... //#DEFINE ENABLE_INTERRUPTS(PIN_B11); 
....................  
.................... void clear_channel() 
006DC:  MOV     W5,[W15++]
006DE:  CLR     102A
006E0:  CLR     102C
.................... { 
....................    int i = 0, k = 0; 
....................    while(i < 8){ 
006E2:  MOV     102A,W4
006E4:  CP      W4,#8
006E6:  BRA     GE,70C
....................       while(k < 3){ 
006E8:  MOV     102C,W4
006EA:  CP      W4,#3
006EC:  BRA     GE,704
....................          channel[i][k] = 0; 
006EE:  MOV     102A,W4
006F0:  MUL.UU  W4,#3,W0
006F2:  MOV     W0,W5
006F4:  MOV     W5,W0
006F6:  ADD     102C,W0
006F8:  MOV     #1002,W4
006FA:  ADD     W0,W4,W5
006FC:  CLR.B   [W5]
....................          k++; 
006FE:  INC     102C
00700:  GOTO    6E8
....................       } 
....................       k = 0; 
00704:  CLR     102C
....................       i++; 
00706:  INC     102A
00708:  GOTO    6E2
....................    } 
0070C:  MOV     [--W15],W5
0070E:  RETURN  
.................... } 
....................  
.................... void display_matrix(void) 
*
003E2:  MOV     W5,[W15++]
003E4:  CLR     1030
003E6:  CLR     1032
.................... { 
....................    int row = 0, columns = 0; 
....................    for (row=0; row<3; row++) 
003E8:  CLR     1030
003EA:  MOV     1030,W4
003EC:  CP      W4,#3
003EE:  BRA     GE,444
....................    { 
....................     for(columns=0; columns<8; columns++) 
003F0:  CLR     1032
003F2:  MOV     1032,W4
003F4:  CP      W4,#8
003F6:  BRA     GE,42E
....................         { 
....................          printf("%d     ", channel[row][columns]); 
003F8:  MOV     1030,W4
003FA:  MUL.UU  W4,#3,W0
003FC:  MOV     W0,W5
003FE:  MOV     W5,W0
00400:  ADD     1032,W0
00402:  MOV     #1002,W4
00404:  ADD     W0,W4,W0
00406:  MOV.B   [W0],W5L
00408:  SE      W5,W0
0040A:  MOV     #0,W4
0040C:  CALL    2E2
00410:  MOV     #2,W1
00412:  MOV     W1,W0
00414:  CLR.B   1
00416:  CALL    200
0041A:  INC     W1,W1
0041C:  BTSC.B  223.1
0041E:  BRA     41C
00420:  MOV     W0,224
00422:  MOV     #6,W0
00424:  CPSGT   W1,W0
00426:  BRA     412
00428:  INC     1032
0042A:  GOTO    3F2
....................         } 
....................       printf("\n\r"); 
0042E:  BTSC.B  223.1
00430:  BRA     42E
00432:  MOV     #A,W4
00434:  MOV     W4,224
00436:  BTSC.B  223.1
00438:  BRA     436
0043A:  MOV     #D,W4
0043C:  MOV     W4,224
0043E:  INC     1030
00440:  GOTO    3EA
....................    } 
00444:  MOV     [--W15],W5
00446:  RETURN  
.................... } 
....................  
.................... #INT_EXT1 
.................... void DCLK_interrupt_handler() 
00448:  PUSH    42
0044A:  PUSH    36
0044C:  PUSH    54
0044E:  MOV     W0,[W15++]
00450:  MOV     #2,W0
00452:  REPEAT  #C
00454:  MOV     [W0++],[W15++]
.................... {         
....................          while(rows <= 8){ 
00456:  MOV     101E,W4
00458:  CP      W4,#8
0045A:  BRA     GT,478
....................          //shift bits left for next inputDMA0   DMA channel 0 transfer complete 
....................             channel[rows][cols] <<= 1; 
0045C:  MOV     101E,W4
0045E:  MUL.UU  W4,#3,W0
00460:  MOV     W0,W5
00462:  MOV     W5,W0
00464:  ADD     1020,W0
00466:  MOV     #1002,W4
00468:  ADD     W0,W4,W5
0046A:  MOV.B   [W5],W0L
0046C:  CLR.B   1
0046E:  SL      W0,#1,W0
00470:  MOV.B   W0L,[W5]
....................             rows++; 
00472:  INC     101E
00474:  GOTO    456
....................          } 
....................         // cols = 0; 
....................          //Accept inputs 1 bit at a time 
....................          channel[0][cols] += input(PIN_B0); 
00478:  MOV     #1002,W4
0047A:  MOV     1020,W3
0047C:  ADD     W3,W4,W5
0047E:  BSET.B  E10.0
00480:  CLR     W0
00482:  BTSC.B  E12.0
00484:  INC     W0,W0
00486:  ADD.B   W0L,[W5],[W5]
....................          channel[1][cols] += input(PIN_B1); 
00488:  MOV     #1005,W0
0048A:  ADD     1020,W0
0048C:  MOV     W0,W5
0048E:  BSET.B  E10.1
00490:  CLR     W0
00492:  BTSC.B  E12.1
00494:  INC     W0,W0
00496:  ADD.B   W0L,[W5],[W5]
....................          channel[2][cols] += input(PIN_B2); 
00498:  MOV     #1008,W0
0049A:  ADD     1020,W0
0049C:  MOV     W0,W5
0049E:  BSET.B  E10.2
004A0:  CLR     W0
004A2:  BTSC.B  E12.2
004A4:  INC     W0,W0
004A6:  ADD.B   W0L,[W5],[W5]
....................          channel[3][cols] += input(PIN_B3); 
004A8:  MOV     #100B,W0
004AA:  ADD     1020,W0
004AC:  MOV     W0,W5
004AE:  BSET.B  E10.3
004B0:  CLR     W0
004B2:  BTSC.B  E12.3
004B4:  INC     W0,W0
004B6:  ADD.B   W0L,[W5],[W5]
....................          channel[4][cols] += input(PIN_B4); 
004B8:  MOV     #100E,W0
004BA:  ADD     1020,W0
004BC:  MOV     W0,W5
004BE:  BSET.B  E10.4
004C0:  CLR     W0
004C2:  BTSC.B  E12.4
004C4:  INC     W0,W0
004C6:  ADD.B   W0L,[W5],[W5]
....................          channel[5][cols] += input(PIN_B5); 
004C8:  MOV     #1011,W0
004CA:  ADD     1020,W0
004CC:  MOV     W0,W5
004CE:  BSET.B  E10.5
004D0:  CLR     W0
004D2:  BTSC.B  E12.5
004D4:  INC     W0,W0
004D6:  ADD.B   W0L,[W5],[W5]
....................          channel[6][cols] += input(PIN_B8); //B6 Used by interrupt 
004D8:  MOV     #1014,W0
004DA:  ADD     1020,W0
004DC:  MOV     W0,W5
004DE:  BSET.B  E11.0
004E0:  CLR     W0
004E2:  BTSC.B  E13.0
004E4:  INC     W0,W0
004E6:  ADD.B   W0L,[W5],[W5]
....................          channel[7][cols] += input(PIN_B9); //B7 Used by interrupt 
004E8:  MOV     #1017,W0
004EA:  ADD     1020,W0
004EC:  MOV     W0,W5
004EE:  BSET.B  E11.1
004F0:  CLR     W0
004F2:  BTSC.B  E13.1
004F4:  INC     W0,W0
004F6:  ADD.B   W0L,[W5],[W5]
....................          //Possible take whole port at one time??? 
....................          //inputPortB = input_b(); 
....................          bitCount++; 
004F8:  INC     101C
....................          printf("Data Reading \n\r"); 
004FA:  MOV     #0,W1
004FC:  MOV     W1,W0
004FE:  CLR.B   1
00500:  CALL    214
00504:  INC     W1,W1
00506:  BTSC.B  223.1
00508:  BRA     506
0050A:  MOV     W0,224
0050C:  MOV     #E,W0
0050E:  CPSGT   W1,W0
00510:  BRA     4FC
....................          if (bitCount == 8){ 
00512:  MOV     101C,W4
00514:  CP      W4,#8
00516:  BRA     NZ,546
....................             if(cols == 3){ 
00518:  MOV     1020,W4
0051A:  CP      W4,#3
0051C:  BRA     NZ,524
....................                cols = 0; 
0051E:  CLR     1020
....................                display_matrix(); 
00520:  CALL    3E2
....................             } 
....................             dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0][0]); 
00524:  BCLR.B  B01.7
00526:  MOV.B   #1,W0L
00528:  MOV.B   W0L,B00
0052A:  MOV     #1002,W4
0052C:  MOV     W4,B04
0052E:  CLR     B06
00530:  BTSS.B  B01.6
00532:  BRA     53A
00534:  MOV     #17,W4
00536:  MOV     W4,B0E
00538:  BRA     53E
0053A:  MOV     #B,W4
0053C:  MOV     W4,B0E
0053E:  BSET.B  B01.7
00540:  BSET.B  B03.7
....................             bitCount = 0;  
00542:  CLR     101C
....................             cols++; 
00544:  INC     1020
....................          } 
....................           
.................... //!   else{ 
.................... //!      printf("24 bits\n\r"); 
.................... //!      bitCount = 0; 
.................... //!      dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0]); 
.................... //!   } 
.................... } 
....................  
....................  
00546:  BCLR.B  802.4
00548:  MOV     #1A,W0
0054A:  REPEAT  #C
0054C:  MOV     [--W15],[W0--]
0054E:  MOV     [--W15],W0
00550:  POP     54
00552:  POP     36
00554:  POP     42
00556:  RETFIE  
.................... #INT_EXT0 
.................... void DRDY_interrupt_handler() 
00558:  PUSH    42
0055A:  PUSH    36
0055C:  PUSH    54
0055E:  MOV     W0,[W15++]
00560:  MOV     #2,W0
00562:  REPEAT  #C
00564:  MOV     [W0++],[W15++]
.................... { 
....................    CLEAR_INTERRUPT(INT_EXT1); 
00566:  BCLR.B  802.4
....................    ENABLE_INTERRUPTS(INT_EXT1); 
00568:  BSET.B  822.4
....................    printf("Waiting for Data Clock \n\r"); 
0056A:  MOV     #0,W1
0056C:  MOV     W1,W0
0056E:  CLR.B   1
00570:  CALL    230
00574:  INC     W1,W1
00576:  BTSC.B  223.1
00578:  BRA     576
0057A:  MOV     W0,224
0057C:  MOV     #18,W0
0057E:  CPSGT   W1,W0
00580:  BRA     56C
.................... } 
....................  
00582:  BCLR.B  800.0
00584:  MOV     #1A,W0
00586:  REPEAT  #C
00588:  MOV     [--W15],[W0--]
0058A:  MOV     [--W15],W0
0058C:  POP     54
0058E:  POP     36
00590:  POP     42
00592:  RETFIE  
.................... #INT_DMA0 
.................... void DMA_interrupt_handler() 
*
0064A:  PUSH    42
0064C:  PUSH    36
0064E:  PUSH    54
00650:  MOV     W0,[W15++]
00652:  MOV     #2,W0
00654:  REPEAT  #C
00656:  MOV     [W0++],[W15++]
.................... { 
....................    printf("DMA Transfer Complete \n\r"); 
00658:  MOV     #0,W1
0065A:  MOV     W1,W0
0065C:  CLR.B   1
0065E:  CALL    256
00662:  INC     W1,W1
00664:  BTSC.B  223.1
00666:  BRA     664
00668:  MOV     W0,224
0066A:  MOV     #17,W0
0066C:  CPSGT   W1,W0
0066E:  BRA     65A
....................    printf("Channel[0][0] is: %u \n\r", channel[0][0]);  
00670:  MOV     #0,W1
00672:  MOV     W1,W0
00674:  CLR.B   1
00676:  CALL    27C
0067A:  INC     W1,W1
0067C:  BTSC.B  223.1
0067E:  BRA     67C
00680:  MOV     W0,224
00682:  MOV     #11,W0
00684:  CPSGT   W1,W0
00686:  BRA     672
00688:  MOV.B   1002,W0L
0068A:  CLR.B   1
0068C:  MOV     #0,W4
0068E:  CALL    594
00692:  BTSC.B  223.1
00694:  BRA     692
00696:  MOV     #20,W4
00698:  MOV     W4,224
0069A:  BTSC.B  223.1
0069C:  BRA     69A
0069E:  MOV     #A,W4
006A0:  MOV     W4,224
006A2:  BTSC.B  223.1
006A4:  BRA     6A2
006A6:  MOV     #D,W4
006A8:  MOV     W4,224
....................  //  clear_channel(); 
006AA:  BCLR.B  800.4
006AC:  MOV     #1A,W0
006AE:  REPEAT  #C
006B0:  MOV     [--W15],[W0--]
006B2:  MOV     [--W15],W0
006B4:  POP     54
006B6:  POP     36
006B8:  POP     42
006BA:  RETFIE  
.................... } 
....................  
....................  
.................... void main(){ 
*
00710:  MOV     #7F80,W15
00712:  MOV     #7FFF,W0
00714:  MOV     W0,20
00716:  NOP     
00718:  BSET.B  8C1.7
0071A:  DISI    #6
0071C:  MOV     #742,W1
0071E:  MOV     #46,W2
00720:  MOV     #57,W3
00722:  MOV.B   W2L,[W1]
00724:  MOV.B   W3L,[W1]
00726:  BCLR.B  742.6
00728:  MOV     #2600,W0
0072A:  MOV     W0,6A0
0072C:  MOV     #2C,W0
0072E:  MOV     W0,6C4
00730:  MOV     #100,W0
00732:  MOV     W0,688
00734:  DISI    #6
00736:  MOV     #742,W1
00738:  MOV     #46,W2
0073A:  MOV     #57,W3
0073C:  MOV.B   W2L,[W1]
0073E:  MOV.B   W3L,[W1]
00740:  BSET.B  742.6
00742:  CLR     744
00744:  MOV     #36,W4
00746:  MOV     W4,746
00748:  DISI    #E
0074A:  MOV     #103,W0
0074C:  MOV     #743,W1
0074E:  MOV     #78,W2
00750:  MOV     #9A,W3
00752:  MOV.B   W2L,[W1]
00754:  MOV.B   W3L,[W1]
00756:  MOV.B   W0L,743
00758:  LSR     W0,#8,W0
0075A:  MOV     #742,W1
0075C:  MOV     #46,W2
0075E:  MOV     #57,W3
00760:  MOV.B   W2L,[W1]
00762:  MOV.B   W3L,[W1]
00764:  MOV.B   W0L,[W1]
00766:  MOV     #8000,W4
00768:  MOV     W4,220
0076A:  MOV     #400,W4
0076C:  MOV     W4,222
0076E:  BCLR.B  220.3
00770:  MOV     #25,W4
00772:  MOV     W4,228
00774:  CLR     101C
00776:  CLR     101E
00778:  CLR     1020
0077A:  BCLR.B  1022.0
0077C:  CLR     E0E
0077E:  CLR     E1E
00780:  CLR     1000
.................... //#BIT INT0EP = 0x08C2.0; 
....................    delay_ms(500); 
00782:  MOV     #1F4,W0
00784:  CALL    6BC
....................    EXT_INT_EDGE(L_TO_H); 
00788:  BCLR.B  8C2.0
....................    int Value; 
....................     
.................... //   INT0EP = 1; // negative edge 
....................     
....................    CLEAR_INTERRUPT(INT_EXT0); 
0078A:  BCLR.B  800.0
....................    ENABLE_INTERRUPTS(INT_EXT0); 
0078C:  BSET.B  820.0
....................    CLEAR_INTERRUPT(INT_DMA0); 
0078E:  BCLR.B  800.4
....................    ENABLE_INTERRUPTS(INT_DMA0); 
00790:  BSET.B  820.4
....................  
....................   // ENABLE_INTERRUPTS(INTR_NORMAL); 
....................    ENABLE_INTERRUPTS(INTR_GLOBAL); 
00792:  BSET.B  8C3.7
....................     
....................    setup_dma(0,DMA_OUT_UART1,DMA_BYTE);    
00794:  MOV.B   #60,W0L
00796:  MOV.B   W0L,B01
00798:  MOV.B   #C,W0L
0079A:  MOV.B   W0L,B02
0079C:  MOV     #224,W4
0079E:  MOV     W4,B0C
....................    //dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................    int i = 0; 
007A0:  CLR     1026
....................    //initialize the array 
....................    clear_channel(); 
007A2:  CALL    6DC
....................     
....................    printf("Test1 \n\r"); 
007A6:  MOV     #0,W1
007A8:  MOV     W1,W0
007AA:  CLR.B   1
007AC:  CALL    2A0
007B0:  INC     W1,W1
007B2:  BTSC.B  223.1
007B4:  BRA     7B2
007B6:  MOV     W0,224
007B8:  MOV     #7,W0
007BA:  CPSGT   W1,W0
007BC:  BRA     7A8
.................... //!  while(count != 5){ 
.................... //!   output_high(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   output_low(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   printf("Hello, World! \n\r"); 
.................... //!   count++; 
.................... //!   } 
....................    delay_ms(200); 
007BE:  MOV     #C8,W0
007C0:  CALL    6BC
007C4:  PUSH    8C2
007C6:  BCLR.B  8C3.7
....................    display_matrix(); 
007C8:  CALL    3E2
007CC:  POP     8C2
....................    while(1) 
....................    { 
....................       delay_ms(2000); 
007CE:  MOV     #7D0,W0
007D0:  CALL    6BC
....................       printf("No \n\r"); 
007D4:  MOV     #0,W1
007D6:  MOV     W1,W0
007D8:  CLR.B   1
007DA:  CALL    2B6
007DE:  INC     W1,W1
007E0:  BTSC.B  223.1
007E2:  BRA     7E0
007E4:  MOV     W0,224
007E6:  MOV     #4,W0
007E8:  CPSGT   W1,W0
007EA:  BRA     7D6
007EC:  GOTO    7CE
....................       //Value = dma_status(0); 
....................       //printf("DMA status: %u \n\r", Value); 
....................      // dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................       
....................    } 
....................    //printf("ch0 is:%u \n\r",ch0); 
....................    int support = getenv("DMA"); 
007F0:  MOV     #1,W4
007F2:  MOV     W4,1028
....................    printf("DMA Valid: %u", support); 
007F4:  MOV     #0,W1
007F6:  MOV     W1,W0
007F8:  CLR.B   1
007FA:  CALL    2C8
007FE:  INC     W1,W1
00800:  BTSC.B  223.1
00802:  BRA     800
00804:  MOV     W0,224
00806:  MOV     #A,W0
00808:  CPSGT   W1,W0
0080A:  BRA     7F6
0080C:  MOV     1028,W0
0080E:  MOV     #0,W4
00810:  CALL    594
.................... } 
*
00814:  PWRSAV  #0

Configuration Fuses:
   Word  3L: FFCF   ICSP1 NOJTAG NODEBUG
          H: 0000  
   Word  4L: FFFF   NOALTI2C1 NOALTI2C2 WDTWIN_25%
          H: 0000  
   Word  5L: FF7F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: 0000  
   Word  6L: FF7A   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  7L: FFF8   FRC IESO
          H: 0000  
   Word  8L: FFFF   NOWRT NOPROTECT
          H: 0000  
   Word  9L: FFFF  
          H: 0000  
   Word 10L: FFFF  
          H: 0000  
