CCS PCD C Compiler, Version 5.071d, 1               11-Jul-17 15:13
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\joshb\OneDrive - St. Cloud State University\PIC24E\DataReading_Working_V2.0\DataReading_DMA_V2.0.lst

               ROM used:   1718 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   186 (1%) at main() level
                           201 (1%) worst case
               Stack used: 74 locations (18 in main + 56 for interrupts)
               Stack size: 128

*
00000:  GOTO    5C6
*
00014:  DATA    2E,05,00
*
0001C:  DATA    6E,05,00
*
0003C:  DATA    CA,03,00
.................... #include <24EP256GP202.h> 
.................... //////////// Standard Header file for the PIC24EP256GP202 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24EP256GP202 
*
00200:  CLR     54
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    25,75,00
0020E:  DATA    20,20,00
00210:  DATA    20,20,00
00212:  DATA    20,00,00
00214:  CLR     54
00216:  MOV     #220,W3
00218:  ADD     W3,W0,W0
0021A:  TBLRDL.B[W0],W0L
0021C:  CLR.B   1
0021E:  RETURN  
00220:  DATA    44,61,00
00222:  DATA    74,61,00
00224:  DATA    20,52,00
00226:  DATA    65,61,00
00228:  DATA    64,69,00
0022A:  DATA    6E,67,00
0022C:  DATA    20,0A,00
0022E:  DATA    0D,00,00
00230:  CLR     54
00232:  MOV     #23C,W3
00234:  ADD     W3,W0,W0
00236:  TBLRDL.B[W0],W0L
00238:  CLR.B   1
0023A:  RETURN  
0023C:  DATA    57,61,00
0023E:  DATA    69,74,00
00240:  DATA    69,6E,00
00242:  DATA    67,20,00
00244:  DATA    66,6F,00
00246:  DATA    72,20,00
00248:  DATA    44,61,00
0024A:  DATA    74,61,00
0024C:  DATA    20,43,00
0024E:  DATA    6C,6F,00
00250:  DATA    63,6B,00
00252:  DATA    20,0A,00
00254:  DATA    0D,00,00
00256:  CLR     54
00258:  MOV     #262,W3
0025A:  ADD     W3,W0,W0
0025C:  TBLRDL.B[W0],W0L
0025E:  CLR.B   1
00260:  RETURN  
00262:  DATA    44,4D,00
00264:  DATA    41,20,00
00266:  DATA    54,72,00
00268:  DATA    61,6E,00
0026A:  DATA    73,66,00
0026C:  DATA    65,72,00
0026E:  DATA    20,43,00
00270:  DATA    6F,6D,00
00272:  DATA    70,6C,00
00274:  DATA    65,74,00
00276:  DATA    65,20,00
00278:  DATA    0A,0D,00
0027A:  DATA    00,00,00
0027C:  CLR     54
0027E:  MOV     #288,W3
00280:  ADD     W3,W0,W0
00282:  TBLRDL.B[W0],W0L
00284:  CLR.B   1
00286:  RETURN  
00288:  DATA    54,65,00
0028A:  DATA    73,74,00
0028C:  DATA    31,20,00
0028E:  DATA    0A,0D,00
00290:  DATA    00,00,00
00292:  CLR     54
00294:  MOV     #29E,W3
00296:  ADD     W3,W0,W0
00298:  TBLRDL.B[W0],W0L
0029A:  CLR.B   1
0029C:  RETURN  
0029E:  DATA    44,4D,00
002A0:  DATA    41,20,00
002A2:  DATA    56,61,00
002A4:  DATA    6C,69,00
002A6:  DATA    64,3A,00
002A8:  DATA    20,25,00
002AA:  DATA    75,00,00
002AC:  MOV     W5,[W15++]
002AE:  MOV     #C,W5
002B0:  REPEAT  #3
002B2:  MOV     [W5++],[W15++]
002B4:  MOV     W0,W7
002B6:  MOV     W4,W9
002B8:  BCLR    W4.F
002BA:  CP0     W4
002BC:  BRA     NZ,2CA
002BE:  BTSC    W9.F
002C0:  BRA     2C6
002C2:  MOV     #0,W5
002C4:  BRA     2E8
002C6:  MOV     #0,W5
002C8:  BRA     2E8
002CA:  SUB.B   W4L,#6,W5L
002CC:  BRA     NC,2E6
002CE:  MOV     #30,W0
002D0:  BTSS    W9.F
002D2:  MOV     #20,W0
002D4:  MOV     W0,[W15++]
002D6:  BTSC.B  223.1
002D8:  BRA     2D6
002DA:  MOV     W0,224
002DC:  MOV     [--W15],W0
002DE:  DEC     W5,W5
002E0:  BRA     NN,2D4
002E2:  MOV     #5,W5
002E4:  BRA     2E8
002E6:  MOV     W4,W5
002E8:  MOV     #6,W4
002EA:  BSET    W5.E
002EC:  BTSC    W9.F
002EE:  BSET    W5.F
002F0:  MOV     #2710,W8
002F2:  REPEAT  #11
002F4:  DIV.U   W7,W8
002F6:  CALL    32A
002FA:  MOV     W1,W7
002FC:  MOV     #3E8,W8
002FE:  REPEAT  #11
00300:  DIV.U   W7,W8
00302:  CALL    32A
00306:  MOV     W1,W7
00308:  MOV     #64,W8
0030A:  REPEAT  #11
0030C:  DIV.U   W7,W8
0030E:  CALL    32A
00312:  MOV     W1,W7
00314:  MOV     #A,W8
00316:  REPEAT  #11
00318:  DIV.U   W7,W8
0031A:  CALL    32A
0031E:  MOV     #30,W0
00320:  ADD.B   W1L,W0L,W0L
00322:  BTSC.B  223.1
00324:  BRA     322
00326:  MOV     W0,224
00328:  BRA     358
0032A:  MOV     #30,W6
0032C:  CP0     W0
0032E:  BRA     NZ,34C
00330:  BTSS    W5.E
00332:  BRA     34E
00334:  DEC     W4,W4
00336:  CP.B    W4L,W5L
00338:  BRA     Z,33E
0033A:  BTSC.B  42.0
0033C:  RETURN  
0033E:  CP0     W0
00340:  BRA     NZ,34C
00342:  BTSS    W5.E
00344:  BRA     34E
00346:  BTSS    W5.F
00348:  MOV     #20,W6
0034A:  BRA     34E
0034C:  BCLR    W5.E
0034E:  ADD.B   W6L,W0L,W0L
00350:  BTSC.B  223.1
00352:  BRA     350
00354:  MOV     W0,224
00356:  RETURN  
00358:  MOV     #12,W5
0035A:  REPEAT  #3
0035C:  MOV     [--W15],[W5--]
0035E:  MOV     [--W15],W5
00360:  RETURN  
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#device icd=true 
.................... //#FUSES FRC_PLL 
.................... #FUSES HS,PR_PLL 
....................  
.................... #use delay(xtal = 10MHZ, clock = 140MHz) 
*
005A6:  CP0     W0
005A8:  BTSC.B  42.1
005AA:  BRA     5C4
005AC:  REPEAT  #116B
005AE:  NOP     
005B0:  REPEAT  #3FFE
005B2:  NOP     
005B4:  REPEAT  #3FFE
005B6:  NOP     
005B8:  REPEAT  #3FFE
005BA:  NOP     
005BC:  REPEAT  #3FFE
005BE:  NOP     
005C0:  DEC     W0,W0
005C2:  BRA     NZ,5AC
005C4:  RETURN  
....................  
.................... #pin_select U1TX = PIN_B11 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232(UART1, baud = 115200, stream = UART_PORT1) 
.................... //#USE RS232(STREAM=UART1, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500, XMIT = PIN_B14, RCV = PIN_B15 )) 
.................... #BANK_DMA  unsigned int channel[8][3]; 
.................... #pin_select INT1 = PIN_B6 
.................... //#define SPI_CS PIN_B6 
.................... //unsigned int32 channel[8];   
.................... //int channel[8]; 
....................  unsigned int rows = 0, cols = 0, bitCount =  0; 
.................... //int j = 0; 
.................... //#DEFINE ENABLE_INTERRUPTS(PIN_B11); 
....................  
.................... void clear_channel() 
*
004F4:  MOV     W5,[W15++]
004F6:  CLR     1042
004F8:  CLR     1044
.................... { 
....................    int i = 0, k = 0; 
....................    while(i < 8){ 
004FA:  MOV     1042,W4
004FC:  CP      W4,#8
004FE:  BRA     GE,52A
....................       while(k < 3){ 
00500:  MOV     1044,W4
00502:  CP      W4,#3
00504:  BRA     GE,522
....................          channel[i][k] = 0; 
00506:  MOV     1042,W4
00508:  MUL.UU  W4,#6,W0
0050A:  MOV     W0,W5
0050C:  MOV     1044,W4
0050E:  MUL.UU  W4,#2,W0
00510:  ADD     W0,W5,W0
00512:  MOV     #1002,W4
00514:  ADD     W0,W4,W5
00516:  CLR.B   [W5]
00518:  MOV.B   #0,W0L
0051A:  MOV.B   W0L,[W5+#1]
....................          k++; 
0051C:  INC     1044
0051E:  GOTO    500
....................       } 
....................       k = 0; 
00522:  CLR     1044
....................       i++; 
00524:  INC     1042
00526:  GOTO    4FA
....................    } 
0052A:  MOV     [--W15],W5
0052C:  RETURN  
.................... } 
....................  
.................... void display_matrix(void) 
*
00362:  MOV     W5,[W15++]
00364:  CLR     1042
00366:  CLR     1044
.................... { 
....................    int row = 0, columns = 0; 
....................    for (row=0; row<8; row++) 
00368:  CLR     1042
0036A:  MOV     1042,W4
0036C:  CP      W4,#8
0036E:  BRA     GE,3C6
....................    { 
....................     for(columns=0; columns<3; columns++) 
00370:  CLR     1044
00372:  MOV     1044,W4
00374:  CP      W4,#3
00376:  BRA     GE,3B0
....................         { 
....................          printf("%u     ", channel[row][columns]); 
00378:  MOV     1042,W4
0037A:  MUL.UU  W4,#6,W0
0037C:  MOV     W0,W5
0037E:  MOV     1044,W4
00380:  MUL.UU  W4,#2,W0
00382:  ADD     W0,W5,W0
00384:  MOV     #1002,W4
00386:  ADD     W0,W4,W0
00388:  MOV     [W0],W5
0038A:  MOV     W5,W0
0038C:  MOV     #0,W4
0038E:  CALL    2AC
00392:  MOV     #2,W1
00394:  MOV     W1,W0
00396:  CLR.B   1
00398:  CALL    200
0039C:  INC     W1,W1
0039E:  BTSC.B  223.1
003A0:  BRA     39E
003A2:  MOV     W0,224
003A4:  MOV     #6,W0
003A6:  CPSGT   W1,W0
003A8:  BRA     394
003AA:  INC     1044
003AC:  GOTO    372
....................         } 
....................       printf("\n\r"); 
003B0:  BTSC.B  223.1
003B2:  BRA     3B0
003B4:  MOV     #A,W4
003B6:  MOV     W4,224
003B8:  BTSC.B  223.1
003BA:  BRA     3B8
003BC:  MOV     #D,W4
003BE:  MOV     W4,224
003C0:  INC     1042
003C2:  GOTO    36A
....................    } 
003C6:  MOV     [--W15],W5
003C8:  RETURN  
.................... } 
....................  
.................... #INT_EXT1 
.................... void DCLK_interrupt_handler() 
003CA:  PUSH    42
003CC:  PUSH    36
003CE:  PUSH    54
003D0:  MOV     W0,[W15++]
003D2:  MOV     #2,W0
003D4:  REPEAT  #C
003D6:  MOV     [W0++],[W15++]
.................... {         
....................          while(rows <= 7){ 
003D8:  MOV     1032,W4
003DA:  CP      W4,#7
003DC:  BRA     GTU,3FA
....................          //shift bits left for next inputDMA0   DMA channel 0 transfer complete 
....................             channel[rows][cols] <<= 1; 
003DE:  MOV     1032,W4
003E0:  MUL.UU  W4,#6,W0
003E2:  MOV     W0,W5
003E4:  MOV     1034,W0
003E6:  SL      W0,#1,W0
003E8:  ADD     W0,W5,W0
003EA:  MOV     #1002,W4
003EC:  ADD     W0,W4,W5
003EE:  MOV     [W5],W0
003F0:  SL      W0,#1,W0
003F2:  MOV     W0,[W5]
....................             rows++; 
003F4:  INC     1032
003F6:  GOTO    3D8
....................          } 
....................           rows = 0; 
003FA:  CLR     1032
....................           bitCount++; 
003FC:  INC     1036
....................          //Accept inputs 1 bit at a time 
....................          channel[0][cols] += input(PIN_B0); 
003FE:  MOV     1034,W0
00400:  SL      W0,#1,W0
00402:  MOV     #1002,W4
00404:  ADD     W0,W4,W5
00406:  BSET.B  E10.0
00408:  CLR     W0
0040A:  BTSC.B  E12.0
0040C:  INC     W0,W0
0040E:  ZE      W0,W0
00410:  ADD     W0,[W5],[W5]
....................          channel[1][cols] += input(PIN_B1); 
00412:  MOV     1034,W0
00414:  SL      W0,#1,W0
00416:  MOV     #1008,W4
00418:  ADD     W0,W4,W5
0041A:  BSET.B  E10.1
0041C:  CLR     W0
0041E:  BTSC.B  E12.1
00420:  INC     W0,W0
00422:  ZE      W0,W0
00424:  ADD     W0,[W5],[W5]
....................          channel[2][cols] += input(PIN_B2); 
00426:  MOV     1034,W0
00428:  SL      W0,#1,W0
0042A:  MOV     #100E,W4
0042C:  ADD     W0,W4,W5
0042E:  BSET.B  E10.2
00430:  CLR     W0
00432:  BTSC.B  E12.2
00434:  INC     W0,W0
00436:  ZE      W0,W0
00438:  ADD     W0,[W5],[W5]
....................          channel[3][cols] += input(PIN_B3); 
0043A:  MOV     1034,W0
0043C:  SL      W0,#1,W0
0043E:  MOV     #1014,W4
00440:  ADD     W0,W4,W5
00442:  BSET.B  E10.3
00444:  CLR     W0
00446:  BTSC.B  E12.3
00448:  INC     W0,W0
0044A:  ZE      W0,W0
0044C:  ADD     W0,[W5],[W5]
....................          channel[4][cols] += input(PIN_B4); 
0044E:  MOV     1034,W0
00450:  SL      W0,#1,W0
00452:  MOV     #101A,W4
00454:  ADD     W0,W4,W5
00456:  BSET.B  E10.4
00458:  CLR     W0
0045A:  BTSC.B  E12.4
0045C:  INC     W0,W0
0045E:  ZE      W0,W0
00460:  ADD     W0,[W5],[W5]
....................          channel[5][cols] += input(PIN_B5); 
00462:  MOV     1034,W0
00464:  SL      W0,#1,W0
00466:  MOV     #1020,W4
00468:  ADD     W0,W4,W5
0046A:  BSET.B  E10.5
0046C:  CLR     W0
0046E:  BTSC.B  E12.5
00470:  INC     W0,W0
00472:  ZE      W0,W0
00474:  ADD     W0,[W5],[W5]
....................          channel[6][cols] += input(PIN_B8); //B6 Used by interrupt 
00476:  MOV     1034,W0
00478:  SL      W0,#1,W0
0047A:  MOV     #1026,W4
0047C:  ADD     W0,W4,W5
0047E:  BSET.B  E11.0
00480:  CLR     W0
00482:  BTSC.B  E13.0
00484:  INC     W0,W0
00486:  ZE      W0,W0
00488:  ADD     W0,[W5],[W5]
....................          channel[7][cols] += input(PIN_B9); //B7 Used by interrupt 
0048A:  MOV     1034,W0
0048C:  SL      W0,#1,W0
0048E:  MOV     #102C,W4
00490:  ADD     W0,W4,W5
00492:  BSET.B  E11.1
00494:  CLR     W0
00496:  BTSC.B  E13.1
00498:  INC     W0,W0
0049A:  ZE      W0,W0
0049C:  ADD     W0,[W5],[W5]
....................          //Possible take whole port at one time??? 
....................          //inputPortB = input_b(); 
....................         // printf("Bitcount = %u \n\r", bitCount);          
....................          printf("Data Reading \n\r"); 
0049E:  MOV     #0,W1
004A0:  MOV     W1,W0
004A2:  CLR.B   1
004A4:  CALL    214
004A8:  INC     W1,W1
004AA:  BTSC.B  223.1
004AC:  BRA     4AA
004AE:  MOV     W0,224
004B0:  MOV     #E,W0
004B2:  CPSGT   W1,W0
004B4:  BRA     4A0
....................          if (bitCount == 8){ 
004B6:  MOV     1036,W4
004B8:  CP      W4,#8
004BA:  BRA     NZ,4E2
....................             if(cols == 2){ 
004BC:  MOV     1034,W4
004BE:  CP      W4,#2
004C0:  BRA     NZ,4CC
....................                //printf("Gets here \n\r" ); 
....................                cols = 0; 
004C2:  CLR     1034
....................                //dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel); 
....................                display_matrix(); 
004C4:  CALL    362
....................             } 
004C8:  GOTO    4CE
....................             else{ 
....................                cols++; 
004CC:  INC     1034
....................             } 
....................             dma_start(0, DMA_ONE_SHOT, &channel,24); 
004CE:  BCLR.B  B01.7
004D0:  MOV.B   #1,W0L
004D2:  MOV.B   W0L,B00
004D4:  MOV     #1002,W4
004D6:  MOV     W4,B04
004D8:  CLR     B06
004DA:  MOV     #18,W4
004DC:  MOV     W4,B0E
004DE:  BSET.B  B01.7
....................             bitCount = 0; 
004E0:  CLR     1036
....................            // printf("Cols %u \n\r", cols); 
....................          } 
....................           
....................           
....................           
.................... //!   else{ 
.................... //!      printf("24 bits\n\r"); 
.................... //!      bitCount = 0; 
.................... //!      dma_start(0, DMA_ONE_SHOT | DMA_FORCE_NOW, &channel[0]); 
.................... //!   } 
.................... } 
....................  
....................  
004E2:  BCLR.B  802.4
004E4:  MOV     #1A,W0
004E6:  REPEAT  #C
004E8:  MOV     [--W15],[W0--]
004EA:  MOV     [--W15],W0
004EC:  POP     54
004EE:  POP     36
004F0:  POP     42
004F2:  RETFIE  
.................... #INT_EXT0 
.................... void DRDY_interrupt_handler() 
*
0052E:  PUSH    42
00530:  PUSH    36
00532:  PUSH    54
00534:  MOV     W0,[W15++]
00536:  MOV     #2,W0
00538:  REPEAT  #C
0053A:  MOV     [W0++],[W15++]
.................... { 
....................    clear_channel(); 
0053C:  CALL    4F4
....................    CLEAR_INTERRUPT(INT_EXT1); 
00540:  BCLR.B  802.4
....................    ENABLE_INTERRUPTS(INT_EXT1); 
00542:  BSET.B  822.4
....................    printf("Waiting for Data Clock \n\r"); 
00544:  MOV     #0,W1
00546:  MOV     W1,W0
00548:  CLR.B   1
0054A:  CALL    230
0054E:  INC     W1,W1
00550:  BTSC.B  223.1
00552:  BRA     550
00554:  MOV     W0,224
00556:  MOV     #18,W0
00558:  CPSGT   W1,W0
0055A:  BRA     546
....................    //dma_start(0, DMA_ONE_SHOT, &channel,24); 
.................... } 
....................  
0055C:  BCLR.B  800.0
0055E:  MOV     #1A,W0
00560:  REPEAT  #C
00562:  MOV     [--W15],[W0--]
00564:  MOV     [--W15],W0
00566:  POP     54
00568:  POP     36
0056A:  POP     42
0056C:  RETFIE  
.................... #INT_DMA0 
.................... void DMA_interrupt_handler() 
0056E:  PUSH    42
00570:  PUSH    36
00572:  PUSH    54
00574:  MOV     W0,[W15++]
00576:  MOV     #2,W0
00578:  REPEAT  #C
0057A:  MOV     [W0++],[W15++]
.................... { 
....................    printf("DMA Transfer Complete \n\r"); 
0057C:  MOV     #0,W1
0057E:  MOV     W1,W0
00580:  CLR.B   1
00582:  CALL    256
00586:  INC     W1,W1
00588:  BTSC.B  223.1
0058A:  BRA     588
0058C:  MOV     W0,224
0058E:  MOV     #17,W0
00590:  CPSGT   W1,W0
00592:  BRA     57E
....................    //printf("Channel[0][0] is: %u \n\r", channel[0][0]);  
....................    //clear_channel(); 
....................    
00594:  BCLR.B  800.4
00596:  MOV     #1A,W0
00598:  REPEAT  #C
0059A:  MOV     [--W15],[W0--]
0059C:  MOV     [--W15],W0
0059E:  POP     54
005A0:  POP     36
005A2:  POP     42
005A4:  RETFIE  
.................... } 
....................  
....................  
.................... void main(){ 
*
005C6:  MOV     #7F80,W15
005C8:  MOV     #7FFF,W0
005CA:  MOV     W0,20
005CC:  NOP     
005CE:  BSET.B  8C1.7
005D0:  DISI    #6
005D2:  MOV     #742,W1
005D4:  MOV     #46,W2
005D6:  MOV     #57,W3
005D8:  MOV.B   W2L,[W1]
005DA:  MOV.B   W3L,[W1]
005DC:  BCLR.B  742.6
005DE:  MOV     #2600,W0
005E0:  MOV     W0,6A0
005E2:  MOV     #2C,W0
005E4:  MOV     W0,6C4
005E6:  MOV     #100,W0
005E8:  MOV     W0,688
005EA:  DISI    #6
005EC:  MOV     #742,W1
005EE:  MOV     #46,W2
005F0:  MOV     #57,W3
005F2:  MOV.B   W2L,[W1]
005F4:  MOV.B   W3L,[W1]
005F6:  BSET.B  742.6
005F8:  CLR     744
005FA:  MOV     #36,W4
005FC:  MOV     W4,746
005FE:  DISI    #E
00600:  MOV     #103,W0
00602:  MOV     #743,W1
00604:  MOV     #78,W2
00606:  MOV     #9A,W3
00608:  MOV.B   W2L,[W1]
0060A:  MOV.B   W3L,[W1]
0060C:  MOV.B   W0L,743
0060E:  LSR     W0,#8,W0
00610:  MOV     #742,W1
00612:  MOV     #46,W2
00614:  MOV     #57,W3
00616:  MOV.B   W2L,[W1]
00618:  MOV.B   W3L,[W1]
0061A:  MOV.B   W0L,[W1]
0061C:  MOV     #8000,W4
0061E:  MOV     W4,220
00620:  MOV     #400,W4
00622:  MOV     W4,222
00624:  BCLR.B  220.3
00626:  MOV     #25,W4
00628:  MOV     W4,228
0062A:  CLR     1032
0062C:  CLR     1034
0062E:  CLR     1036
00630:  CLR     E0E
00632:  CLR     E1E
00634:  CLR     1000
.................... //#BIT INT0EP = 0x08C2.0; 
....................    delay_ms(500); 
00636:  MOV     #1F4,W0
00638:  CALL    5A6
....................    EXT_INT_EDGE(L_TO_H); 
0063C:  BCLR.B  8C2.0
....................     
.................... //   INT0EP = 1; // negative edge 
....................     
....................    CLEAR_INTERRUPT(INT_EXT0); 
0063E:  BCLR.B  800.0
....................    ENABLE_INTERRUPTS(INT_EXT0); 
00640:  BSET.B  820.0
....................    CLEAR_INTERRUPT(INT_DMA0); 
00642:  BCLR.B  800.4
....................    ENABLE_INTERRUPTS(INT_DMA0); 
00644:  BSET.B  820.4
....................  
....................   // ENABLE_INTERRUPTS(INTR_NORMAL); 
....................    ENABLE_INTERRUPTS(INTR_GLOBAL); 
00646:  BSET.B  8C3.7
....................     
....................    setup_dma(0,DMA_OUT_UART1,DMA_WORD);    
00648:  MOV.B   #20,W0L
0064A:  MOV.B   W0L,B01
0064C:  MOV.B   #C,W0L
0064E:  MOV.B   W0L,B02
00650:  MOV     #224,W4
00652:  MOV     W4,B0C
00654:  PUSH    8C2
00656:  BCLR.B  8C3.7
....................    //dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................    //initialize the array 
....................    clear_channel(); 
00658:  CALL    4F4
0065C:  POP     8C2
....................     
....................    printf("Test1 \n\r"); 
0065E:  MOV     #0,W1
00660:  MOV     W1,W0
00662:  CLR.B   1
00664:  CALL    27C
00668:  INC     W1,W1
0066A:  BTSC.B  223.1
0066C:  BRA     66A
0066E:  MOV     W0,224
00670:  MOV     #7,W0
00672:  CPSGT   W1,W0
00674:  BRA     660
.................... //!  while(count != 5){ 
.................... //!   output_high(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   output_low(PIN_A0); 
.................... //!   delay_ms(100); 
.................... //!   printf("Hello, World! \n\r"); 
.................... //!   count++; 
.................... //!   } 
....................    delay_ms(200); 
00676:  MOV     #C8,W0
00678:  CALL    5A6
0067C:  PUSH    8C2
0067E:  BCLR.B  8C3.7
....................    display_matrix(); 
00680:  CALL    362
00684:  POP     8C2
....................    while(1) 
....................    { 
00686:  GOTO    686
....................       //delay_ms(5000); 
....................       //printf("No \n\r"); 
....................       //Value = dma_status(0); 
....................       //printf("DMA status: %u \n\r", Value); 
....................      // dma_start(1,DMA_ONE_SHOT , 0x4000,0); 
....................       
....................    } 
....................    //printf("ch0 is:%u \n\r",ch0); 
....................    int support = getenv("DMA"); 
0068A:  MOV     #1,W4
0068C:  MOV     W4,1038
....................    printf("DMA Valid: %u", support); 
0068E:  MOV     #0,W1
00690:  MOV     W1,W0
00692:  CLR.B   1
00694:  CALL    292
00698:  INC     W1,W1
0069A:  BTSC.B  223.1
0069C:  BRA     69A
0069E:  MOV     W0,224
006A0:  MOV     #A,W0
006A2:  CPSGT   W1,W0
006A4:  BRA     690
006A6:  PUSH    8C2
006A8:  BCLR.B  8C3.7
006AA:  MOV     1038,W0
006AC:  MOV     #0,W4
006AE:  CALL    2AC
006B2:  POP     8C2
.................... } 
006B4:  PWRSAV  #0

Configuration Fuses:
   Word  3L: FFCF   ICSP1 NOJTAG NODEBUG
          H: 0000  
   Word  4L: FFFF   NOALTI2C1 NOALTI2C2 WDTWIN_25%
          H: 0000  
   Word  5L: FF7F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: 0000  
   Word  6L: FF7A   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  7L: FFF8   FRC IESO
          H: 0000  
   Word  8L: FFFF   NOWRT NOPROTECT
          H: 0000  
   Word  9L: FFFF  
          H: 0000  
   Word 10L: FFFF  
          H: 0000  
